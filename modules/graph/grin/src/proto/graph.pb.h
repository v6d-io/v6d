// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: graph.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_graph_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_graph_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_graph_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_graph_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_graph_2eproto;
namespace grin {
class EdgePropertyFeature;
struct EdgePropertyFeatureDefaultTypeInternal;
extern EdgePropertyFeatureDefaultTypeInternal _EdgePropertyFeature_default_instance_;
class Graph;
struct GraphDefaultTypeInternal;
extern GraphDefaultTypeInternal _Graph_default_instance_;
class IndexFeature;
struct IndexFeatureDefaultTypeInternal;
extern IndexFeatureDefaultTypeInternal _IndexFeature_default_instance_;
class MirrorPartitionListFeature;
struct MirrorPartitionListFeatureDefaultTypeInternal;
extern MirrorPartitionListFeatureDefaultTypeInternal _MirrorPartitionListFeature_default_instance_;
class PartitionFeature;
struct PartitionFeatureDefaultTypeInternal;
extern PartitionFeatureDefaultTypeInternal _PartitionFeature_default_instance_;
class PredicateFeature;
struct PredicateFeatureDefaultTypeInternal;
extern PredicateFeatureDefaultTypeInternal _PredicateFeature_default_instance_;
class PropertyFeature;
struct PropertyFeatureDefaultTypeInternal;
extern PropertyFeatureDefaultTypeInternal _PropertyFeature_default_instance_;
class Statistics;
struct StatisticsDefaultTypeInternal;
extern StatisticsDefaultTypeInternal _Statistics_default_instance_;
class StorageFeature;
struct StorageFeatureDefaultTypeInternal;
extern StorageFeatureDefaultTypeInternal _StorageFeature_default_instance_;
class TopologyFeature;
struct TopologyFeatureDefaultTypeInternal;
extern TopologyFeatureDefaultTypeInternal _TopologyFeature_default_instance_;
class VertexPropertyFeature;
struct VertexPropertyFeatureDefaultTypeInternal;
extern VertexPropertyFeatureDefaultTypeInternal _VertexPropertyFeature_default_instance_;
}  // namespace grin
PROTOBUF_NAMESPACE_OPEN
template<> ::grin::EdgePropertyFeature* Arena::CreateMaybeMessage<::grin::EdgePropertyFeature>(Arena*);
template<> ::grin::Graph* Arena::CreateMaybeMessage<::grin::Graph>(Arena*);
template<> ::grin::IndexFeature* Arena::CreateMaybeMessage<::grin::IndexFeature>(Arena*);
template<> ::grin::MirrorPartitionListFeature* Arena::CreateMaybeMessage<::grin::MirrorPartitionListFeature>(Arena*);
template<> ::grin::PartitionFeature* Arena::CreateMaybeMessage<::grin::PartitionFeature>(Arena*);
template<> ::grin::PredicateFeature* Arena::CreateMaybeMessage<::grin::PredicateFeature>(Arena*);
template<> ::grin::PropertyFeature* Arena::CreateMaybeMessage<::grin::PropertyFeature>(Arena*);
template<> ::grin::Statistics* Arena::CreateMaybeMessage<::grin::Statistics>(Arena*);
template<> ::grin::StorageFeature* Arena::CreateMaybeMessage<::grin::StorageFeature>(Arena*);
template<> ::grin::TopologyFeature* Arena::CreateMaybeMessage<::grin::TopologyFeature>(Arena*);
template<> ::grin::VertexPropertyFeature* Arena::CreateMaybeMessage<::grin::VertexPropertyFeature>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace grin {

enum ListRetrieval : int {
  LR_NA = 0,
  LR_ARRAY_LIKE = 1,
  LR_ITERATOR = 2,
  ListRetrieval_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ListRetrieval_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ListRetrieval_IsValid(int value);
constexpr ListRetrieval ListRetrieval_MIN = LR_NA;
constexpr ListRetrieval ListRetrieval_MAX = LR_ITERATOR;
constexpr int ListRetrieval_ARRAYSIZE = ListRetrieval_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ListRetrieval_descriptor();
template<typename T>
inline const std::string& ListRetrieval_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ListRetrieval>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ListRetrieval_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ListRetrieval_descriptor(), enum_t_value);
}
inline bool ListRetrieval_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ListRetrieval* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ListRetrieval>(
    ListRetrieval_descriptor(), name, value);
}
enum GraphPartitionStrategy : int {
  GPS_NA = 0,
  GPS_ALL_REPLICATE = 1,
  GPS_EDGE_CUT = 2,
  GPS_VERTEX_CUT = 3,
  GPS_HYBRID_CUT = 4,
  GraphPartitionStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GraphPartitionStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GraphPartitionStrategy_IsValid(int value);
constexpr GraphPartitionStrategy GraphPartitionStrategy_MIN = GPS_NA;
constexpr GraphPartitionStrategy GraphPartitionStrategy_MAX = GPS_HYBRID_CUT;
constexpr int GraphPartitionStrategy_ARRAYSIZE = GraphPartitionStrategy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GraphPartitionStrategy_descriptor();
template<typename T>
inline const std::string& GraphPartitionStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GraphPartitionStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GraphPartitionStrategy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GraphPartitionStrategy_descriptor(), enum_t_value);
}
inline bool GraphPartitionStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GraphPartitionStrategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GraphPartitionStrategy>(
    GraphPartitionStrategy_descriptor(), name, value);
}
enum PropertyDataPartitionStrategy : int {
  PDPS_NA = 0,
  PDPS_MASTER_ONLY = 1,
  PDPS_REPLICATE_MASTER_MIRROR = 2,
  PDPS_SPLIT_MASTER_MIRROR = 3,
  PropertyDataPartitionStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PropertyDataPartitionStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PropertyDataPartitionStrategy_IsValid(int value);
constexpr PropertyDataPartitionStrategy PropertyDataPartitionStrategy_MIN = PDPS_NA;
constexpr PropertyDataPartitionStrategy PropertyDataPartitionStrategy_MAX = PDPS_SPLIT_MASTER_MIRROR;
constexpr int PropertyDataPartitionStrategy_ARRAYSIZE = PropertyDataPartitionStrategy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PropertyDataPartitionStrategy_descriptor();
template<typename T>
inline const std::string& PropertyDataPartitionStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PropertyDataPartitionStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PropertyDataPartitionStrategy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PropertyDataPartitionStrategy_descriptor(), enum_t_value);
}
inline bool PropertyDataPartitionStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PropertyDataPartitionStrategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PropertyDataPartitionStrategy>(
    PropertyDataPartitionStrategy_descriptor(), name, value);
}
// ===================================================================

class TopologyFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grin.TopologyFeature) */ {
 public:
  inline TopologyFeature() : TopologyFeature(nullptr) {}
  ~TopologyFeature() override;
  explicit PROTOBUF_CONSTEXPR TopologyFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TopologyFeature(const TopologyFeature& from);
  TopologyFeature(TopologyFeature&& from) noexcept
    : TopologyFeature() {
    *this = ::std::move(from);
  }

  inline TopologyFeature& operator=(const TopologyFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopologyFeature& operator=(TopologyFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TopologyFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const TopologyFeature* internal_default_instance() {
    return reinterpret_cast<const TopologyFeature*>(
               &_TopologyFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TopologyFeature& a, TopologyFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(TopologyFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopologyFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TopologyFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TopologyFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TopologyFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TopologyFeature& from) {
    TopologyFeature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TopologyFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grin.TopologyFeature";
  }
  protected:
  explicit TopologyFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVertexListRetrievalsFieldNumber = 7,
    kEdgeListRetrievalsFieldNumber = 8,
    kAdjacentListRetrievalsFieldNumber = 9,
    kGrinAssumeHasDirectedGraphFieldNumber = 1,
    kGrinAssumeHasUndirectedGraphFieldNumber = 2,
    kGrinAssumeHasMultiEdgeGraphFieldNumber = 3,
    kGrinWithVertexOriginalIdFieldNumber = 4,
    kGrinWithVertexDataFieldNumber = 5,
    kGrinWithEdgeDataFieldNumber = 6,
  };
  // repeated .grin.ListRetrieval vertex_list_retrievals = 7;
  int vertex_list_retrievals_size() const;
  private:
  int _internal_vertex_list_retrievals_size() const;
  public:
  void clear_vertex_list_retrievals();
  private:
  ::grin::ListRetrieval _internal_vertex_list_retrievals(int index) const;
  void _internal_add_vertex_list_retrievals(::grin::ListRetrieval value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_vertex_list_retrievals();
  public:
  ::grin::ListRetrieval vertex_list_retrievals(int index) const;
  void set_vertex_list_retrievals(int index, ::grin::ListRetrieval value);
  void add_vertex_list_retrievals(::grin::ListRetrieval value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& vertex_list_retrievals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_vertex_list_retrievals();

  // repeated .grin.ListRetrieval edge_list_retrievals = 8;
  int edge_list_retrievals_size() const;
  private:
  int _internal_edge_list_retrievals_size() const;
  public:
  void clear_edge_list_retrievals();
  private:
  ::grin::ListRetrieval _internal_edge_list_retrievals(int index) const;
  void _internal_add_edge_list_retrievals(::grin::ListRetrieval value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_edge_list_retrievals();
  public:
  ::grin::ListRetrieval edge_list_retrievals(int index) const;
  void set_edge_list_retrievals(int index, ::grin::ListRetrieval value);
  void add_edge_list_retrievals(::grin::ListRetrieval value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& edge_list_retrievals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_edge_list_retrievals();

  // repeated .grin.ListRetrieval adjacent_list_retrievals = 9;
  int adjacent_list_retrievals_size() const;
  private:
  int _internal_adjacent_list_retrievals_size() const;
  public:
  void clear_adjacent_list_retrievals();
  private:
  ::grin::ListRetrieval _internal_adjacent_list_retrievals(int index) const;
  void _internal_add_adjacent_list_retrievals(::grin::ListRetrieval value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_adjacent_list_retrievals();
  public:
  ::grin::ListRetrieval adjacent_list_retrievals(int index) const;
  void set_adjacent_list_retrievals(int index, ::grin::ListRetrieval value);
  void add_adjacent_list_retrievals(::grin::ListRetrieval value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& adjacent_list_retrievals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_adjacent_list_retrievals();

  // bool grin_assume_has_directed_graph = 1;
  void clear_grin_assume_has_directed_graph();
  bool grin_assume_has_directed_graph() const;
  void set_grin_assume_has_directed_graph(bool value);
  private:
  bool _internal_grin_assume_has_directed_graph() const;
  void _internal_set_grin_assume_has_directed_graph(bool value);
  public:

  // bool grin_assume_has_undirected_graph = 2;
  void clear_grin_assume_has_undirected_graph();
  bool grin_assume_has_undirected_graph() const;
  void set_grin_assume_has_undirected_graph(bool value);
  private:
  bool _internal_grin_assume_has_undirected_graph() const;
  void _internal_set_grin_assume_has_undirected_graph(bool value);
  public:

  // bool grin_assume_has_multi_edge_graph = 3;
  void clear_grin_assume_has_multi_edge_graph();
  bool grin_assume_has_multi_edge_graph() const;
  void set_grin_assume_has_multi_edge_graph(bool value);
  private:
  bool _internal_grin_assume_has_multi_edge_graph() const;
  void _internal_set_grin_assume_has_multi_edge_graph(bool value);
  public:

  // bool grin_with_vertex_original_id = 4;
  void clear_grin_with_vertex_original_id();
  bool grin_with_vertex_original_id() const;
  void set_grin_with_vertex_original_id(bool value);
  private:
  bool _internal_grin_with_vertex_original_id() const;
  void _internal_set_grin_with_vertex_original_id(bool value);
  public:

  // bool grin_with_vertex_data = 5;
  void clear_grin_with_vertex_data();
  bool grin_with_vertex_data() const;
  void set_grin_with_vertex_data(bool value);
  private:
  bool _internal_grin_with_vertex_data() const;
  void _internal_set_grin_with_vertex_data(bool value);
  public:

  // bool grin_with_edge_data = 6;
  void clear_grin_with_edge_data();
  bool grin_with_edge_data() const;
  void set_grin_with_edge_data(bool value);
  private:
  bool _internal_grin_with_edge_data() const;
  void _internal_set_grin_with_edge_data(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grin.TopologyFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> vertex_list_retrievals_;
    mutable std::atomic<int> _vertex_list_retrievals_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> edge_list_retrievals_;
    mutable std::atomic<int> _edge_list_retrievals_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> adjacent_list_retrievals_;
    mutable std::atomic<int> _adjacent_list_retrievals_cached_byte_size_;
    bool grin_assume_has_directed_graph_;
    bool grin_assume_has_undirected_graph_;
    bool grin_assume_has_multi_edge_graph_;
    bool grin_with_vertex_original_id_;
    bool grin_with_vertex_data_;
    bool grin_with_edge_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_graph_2eproto;
};
// -------------------------------------------------------------------

class MirrorPartitionListFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grin.MirrorPartitionListFeature) */ {
 public:
  inline MirrorPartitionListFeature() : MirrorPartitionListFeature(nullptr) {}
  ~MirrorPartitionListFeature() override;
  explicit PROTOBUF_CONSTEXPR MirrorPartitionListFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MirrorPartitionListFeature(const MirrorPartitionListFeature& from);
  MirrorPartitionListFeature(MirrorPartitionListFeature&& from) noexcept
    : MirrorPartitionListFeature() {
    *this = ::std::move(from);
  }

  inline MirrorPartitionListFeature& operator=(const MirrorPartitionListFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline MirrorPartitionListFeature& operator=(MirrorPartitionListFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MirrorPartitionListFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const MirrorPartitionListFeature* internal_default_instance() {
    return reinterpret_cast<const MirrorPartitionListFeature*>(
               &_MirrorPartitionListFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MirrorPartitionListFeature& a, MirrorPartitionListFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(MirrorPartitionListFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MirrorPartitionListFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MirrorPartitionListFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MirrorPartitionListFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MirrorPartitionListFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MirrorPartitionListFeature& from) {
    MirrorPartitionListFeature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MirrorPartitionListFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grin.MirrorPartitionListFeature";
  }
  protected:
  explicit MirrorPartitionListFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGrinTraitMasterVertexMirrorPartitionListFieldNumber = 1,
    kGrinTraitMirrorVertexMirrorPartitionListFieldNumber = 2,
    kGrinTraitMasterEdgeMirrorPartitionListFieldNumber = 3,
    kGrinTraitMirrorEdgeMirrorPartitionListFieldNumber = 4,
  };
  // bool grin_trait_master_vertex_mirror_partition_list = 1;
  void clear_grin_trait_master_vertex_mirror_partition_list();
  bool grin_trait_master_vertex_mirror_partition_list() const;
  void set_grin_trait_master_vertex_mirror_partition_list(bool value);
  private:
  bool _internal_grin_trait_master_vertex_mirror_partition_list() const;
  void _internal_set_grin_trait_master_vertex_mirror_partition_list(bool value);
  public:

  // bool grin_trait_mirror_vertex_mirror_partition_list = 2;
  void clear_grin_trait_mirror_vertex_mirror_partition_list();
  bool grin_trait_mirror_vertex_mirror_partition_list() const;
  void set_grin_trait_mirror_vertex_mirror_partition_list(bool value);
  private:
  bool _internal_grin_trait_mirror_vertex_mirror_partition_list() const;
  void _internal_set_grin_trait_mirror_vertex_mirror_partition_list(bool value);
  public:

  // bool grin_trait_master_edge_mirror_partition_list = 3;
  void clear_grin_trait_master_edge_mirror_partition_list();
  bool grin_trait_master_edge_mirror_partition_list() const;
  void set_grin_trait_master_edge_mirror_partition_list(bool value);
  private:
  bool _internal_grin_trait_master_edge_mirror_partition_list() const;
  void _internal_set_grin_trait_master_edge_mirror_partition_list(bool value);
  public:

  // bool grin_trait_mirror_edge_mirror_partition_list = 4;
  void clear_grin_trait_mirror_edge_mirror_partition_list();
  bool grin_trait_mirror_edge_mirror_partition_list() const;
  void set_grin_trait_mirror_edge_mirror_partition_list(bool value);
  private:
  bool _internal_grin_trait_mirror_edge_mirror_partition_list() const;
  void _internal_set_grin_trait_mirror_edge_mirror_partition_list(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grin.MirrorPartitionListFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool grin_trait_master_vertex_mirror_partition_list_;
    bool grin_trait_mirror_vertex_mirror_partition_list_;
    bool grin_trait_master_edge_mirror_partition_list_;
    bool grin_trait_mirror_edge_mirror_partition_list_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_graph_2eproto;
};
// -------------------------------------------------------------------

class PartitionFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grin.PartitionFeature) */ {
 public:
  inline PartitionFeature() : PartitionFeature(nullptr) {}
  ~PartitionFeature() override;
  explicit PROTOBUF_CONSTEXPR PartitionFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionFeature(const PartitionFeature& from);
  PartitionFeature(PartitionFeature&& from) noexcept
    : PartitionFeature() {
    *this = ::std::move(from);
  }

  inline PartitionFeature& operator=(const PartitionFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionFeature& operator=(PartitionFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionFeature* internal_default_instance() {
    return reinterpret_cast<const PartitionFeature*>(
               &_PartitionFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PartitionFeature& a, PartitionFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartitionFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PartitionFeature& from) {
    PartitionFeature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grin.PartitionFeature";
  }
  protected:
  explicit PartitionFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMirrorPartitionListFeatureFieldNumber = 7,
    kGraphPartitionStrategyFieldNumber = 1,
    kGrinTraitNaturalIdForPartitionFieldNumber = 2,
    kGrinEnableVertexRefFieldNumber = 3,
    kGrinEnableEdgeRefFieldNumber = 4,
    kGrinTraitSelectMasterForVertexListFieldNumber = 8,
    kVertexDataFieldNumber = 5,
    kEdgeDataFieldNumber = 6,
    kGrinTraitSelectPartitionForVertexListFieldNumber = 9,
    kGrinTraitSelectMasterForEdgeListFieldNumber = 10,
    kGrinTraitSelectPartitionForEdgeListFieldNumber = 11,
    kGrinTraitSelectMasterNeighborForAdjacentListFieldNumber = 12,
    kGrinTraitSelectNeighborPartitionForAdjacentListFieldNumber = 13,
  };
  // .grin.MirrorPartitionListFeature mirror_partition_list_feature = 7;
  bool has_mirror_partition_list_feature() const;
  private:
  bool _internal_has_mirror_partition_list_feature() const;
  public:
  void clear_mirror_partition_list_feature();
  const ::grin::MirrorPartitionListFeature& mirror_partition_list_feature() const;
  PROTOBUF_NODISCARD ::grin::MirrorPartitionListFeature* release_mirror_partition_list_feature();
  ::grin::MirrorPartitionListFeature* mutable_mirror_partition_list_feature();
  void set_allocated_mirror_partition_list_feature(::grin::MirrorPartitionListFeature* mirror_partition_list_feature);
  private:
  const ::grin::MirrorPartitionListFeature& _internal_mirror_partition_list_feature() const;
  ::grin::MirrorPartitionListFeature* _internal_mutable_mirror_partition_list_feature();
  public:
  void unsafe_arena_set_allocated_mirror_partition_list_feature(
      ::grin::MirrorPartitionListFeature* mirror_partition_list_feature);
  ::grin::MirrorPartitionListFeature* unsafe_arena_release_mirror_partition_list_feature();

  // .grin.GraphPartitionStrategy graph_partition_strategy = 1;
  void clear_graph_partition_strategy();
  ::grin::GraphPartitionStrategy graph_partition_strategy() const;
  void set_graph_partition_strategy(::grin::GraphPartitionStrategy value);
  private:
  ::grin::GraphPartitionStrategy _internal_graph_partition_strategy() const;
  void _internal_set_graph_partition_strategy(::grin::GraphPartitionStrategy value);
  public:

  // bool grin_trait_natural_id_for_partition = 2;
  void clear_grin_trait_natural_id_for_partition();
  bool grin_trait_natural_id_for_partition() const;
  void set_grin_trait_natural_id_for_partition(bool value);
  private:
  bool _internal_grin_trait_natural_id_for_partition() const;
  void _internal_set_grin_trait_natural_id_for_partition(bool value);
  public:

  // bool grin_enable_vertex_ref = 3;
  void clear_grin_enable_vertex_ref();
  bool grin_enable_vertex_ref() const;
  void set_grin_enable_vertex_ref(bool value);
  private:
  bool _internal_grin_enable_vertex_ref() const;
  void _internal_set_grin_enable_vertex_ref(bool value);
  public:

  // bool grin_enable_edge_ref = 4;
  void clear_grin_enable_edge_ref();
  bool grin_enable_edge_ref() const;
  void set_grin_enable_edge_ref(bool value);
  private:
  bool _internal_grin_enable_edge_ref() const;
  void _internal_set_grin_enable_edge_ref(bool value);
  public:

  // bool grin_trait_select_master_for_vertex_list = 8;
  void clear_grin_trait_select_master_for_vertex_list();
  bool grin_trait_select_master_for_vertex_list() const;
  void set_grin_trait_select_master_for_vertex_list(bool value);
  private:
  bool _internal_grin_trait_select_master_for_vertex_list() const;
  void _internal_set_grin_trait_select_master_for_vertex_list(bool value);
  public:

  // .grin.PropertyDataPartitionStrategy vertex_data = 5;
  void clear_vertex_data();
  ::grin::PropertyDataPartitionStrategy vertex_data() const;
  void set_vertex_data(::grin::PropertyDataPartitionStrategy value);
  private:
  ::grin::PropertyDataPartitionStrategy _internal_vertex_data() const;
  void _internal_set_vertex_data(::grin::PropertyDataPartitionStrategy value);
  public:

  // .grin.PropertyDataPartitionStrategy edge_data = 6;
  void clear_edge_data();
  ::grin::PropertyDataPartitionStrategy edge_data() const;
  void set_edge_data(::grin::PropertyDataPartitionStrategy value);
  private:
  ::grin::PropertyDataPartitionStrategy _internal_edge_data() const;
  void _internal_set_edge_data(::grin::PropertyDataPartitionStrategy value);
  public:

  // bool grin_trait_select_partition_for_vertex_list = 9;
  void clear_grin_trait_select_partition_for_vertex_list();
  bool grin_trait_select_partition_for_vertex_list() const;
  void set_grin_trait_select_partition_for_vertex_list(bool value);
  private:
  bool _internal_grin_trait_select_partition_for_vertex_list() const;
  void _internal_set_grin_trait_select_partition_for_vertex_list(bool value);
  public:

  // bool grin_trait_select_master_for_edge_list = 10;
  void clear_grin_trait_select_master_for_edge_list();
  bool grin_trait_select_master_for_edge_list() const;
  void set_grin_trait_select_master_for_edge_list(bool value);
  private:
  bool _internal_grin_trait_select_master_for_edge_list() const;
  void _internal_set_grin_trait_select_master_for_edge_list(bool value);
  public:

  // bool grin_trait_select_partition_for_edge_list = 11;
  void clear_grin_trait_select_partition_for_edge_list();
  bool grin_trait_select_partition_for_edge_list() const;
  void set_grin_trait_select_partition_for_edge_list(bool value);
  private:
  bool _internal_grin_trait_select_partition_for_edge_list() const;
  void _internal_set_grin_trait_select_partition_for_edge_list(bool value);
  public:

  // bool grin_trait_select_master_neighbor_for_adjacent_list = 12;
  void clear_grin_trait_select_master_neighbor_for_adjacent_list();
  bool grin_trait_select_master_neighbor_for_adjacent_list() const;
  void set_grin_trait_select_master_neighbor_for_adjacent_list(bool value);
  private:
  bool _internal_grin_trait_select_master_neighbor_for_adjacent_list() const;
  void _internal_set_grin_trait_select_master_neighbor_for_adjacent_list(bool value);
  public:

  // bool grin_trait_select_neighbor_partition_for_adjacent_list = 13;
  void clear_grin_trait_select_neighbor_partition_for_adjacent_list();
  bool grin_trait_select_neighbor_partition_for_adjacent_list() const;
  void set_grin_trait_select_neighbor_partition_for_adjacent_list(bool value);
  private:
  bool _internal_grin_trait_select_neighbor_partition_for_adjacent_list() const;
  void _internal_set_grin_trait_select_neighbor_partition_for_adjacent_list(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grin.PartitionFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::grin::MirrorPartitionListFeature* mirror_partition_list_feature_;
    int graph_partition_strategy_;
    bool grin_trait_natural_id_for_partition_;
    bool grin_enable_vertex_ref_;
    bool grin_enable_edge_ref_;
    bool grin_trait_select_master_for_vertex_list_;
    int vertex_data_;
    int edge_data_;
    bool grin_trait_select_partition_for_vertex_list_;
    bool grin_trait_select_master_for_edge_list_;
    bool grin_trait_select_partition_for_edge_list_;
    bool grin_trait_select_master_neighbor_for_adjacent_list_;
    bool grin_trait_select_neighbor_partition_for_adjacent_list_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_graph_2eproto;
};
// -------------------------------------------------------------------

class VertexPropertyFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grin.VertexPropertyFeature) */ {
 public:
  inline VertexPropertyFeature() : VertexPropertyFeature(nullptr) {}
  ~VertexPropertyFeature() override;
  explicit PROTOBUF_CONSTEXPR VertexPropertyFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VertexPropertyFeature(const VertexPropertyFeature& from);
  VertexPropertyFeature(VertexPropertyFeature&& from) noexcept
    : VertexPropertyFeature() {
    *this = ::std::move(from);
  }

  inline VertexPropertyFeature& operator=(const VertexPropertyFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline VertexPropertyFeature& operator=(VertexPropertyFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VertexPropertyFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const VertexPropertyFeature* internal_default_instance() {
    return reinterpret_cast<const VertexPropertyFeature*>(
               &_VertexPropertyFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VertexPropertyFeature& a, VertexPropertyFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(VertexPropertyFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VertexPropertyFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VertexPropertyFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VertexPropertyFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VertexPropertyFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VertexPropertyFeature& from) {
    VertexPropertyFeature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VertexPropertyFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grin.VertexPropertyFeature";
  }
  protected:
  explicit VertexPropertyFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGrinWithVertexPropertyFieldNumber = 1,
    kGrinWithVertexPropertyNameFieldNumber = 2,
    kGrinWithVertexTypeNameFieldNumber = 3,
    kGrinEnableVertexPropertyTableFieldNumber = 4,
    kGrinEnableVertexPrimaryKeysFieldNumber = 5,
    kGrinTraitNaturalIdForVertexTypeFieldNumber = 6,
    kGrinTraitNaturalIdForVertexPropertyFieldNumber = 7,
    kGrinAssumeByTypeVertexOriginalIdFieldNumber = 8,
  };
  // bool grin_with_vertex_property = 1;
  void clear_grin_with_vertex_property();
  bool grin_with_vertex_property() const;
  void set_grin_with_vertex_property(bool value);
  private:
  bool _internal_grin_with_vertex_property() const;
  void _internal_set_grin_with_vertex_property(bool value);
  public:

  // bool grin_with_vertex_property_name = 2;
  void clear_grin_with_vertex_property_name();
  bool grin_with_vertex_property_name() const;
  void set_grin_with_vertex_property_name(bool value);
  private:
  bool _internal_grin_with_vertex_property_name() const;
  void _internal_set_grin_with_vertex_property_name(bool value);
  public:

  // bool grin_with_vertex_type_name = 3;
  void clear_grin_with_vertex_type_name();
  bool grin_with_vertex_type_name() const;
  void set_grin_with_vertex_type_name(bool value);
  private:
  bool _internal_grin_with_vertex_type_name() const;
  void _internal_set_grin_with_vertex_type_name(bool value);
  public:

  // bool grin_enable_vertex_property_table = 4;
  void clear_grin_enable_vertex_property_table();
  bool grin_enable_vertex_property_table() const;
  void set_grin_enable_vertex_property_table(bool value);
  private:
  bool _internal_grin_enable_vertex_property_table() const;
  void _internal_set_grin_enable_vertex_property_table(bool value);
  public:

  // bool grin_enable_vertex_primary_keys = 5;
  void clear_grin_enable_vertex_primary_keys();
  bool grin_enable_vertex_primary_keys() const;
  void set_grin_enable_vertex_primary_keys(bool value);
  private:
  bool _internal_grin_enable_vertex_primary_keys() const;
  void _internal_set_grin_enable_vertex_primary_keys(bool value);
  public:

  // bool grin_trait_natural_id_for_vertex_type = 6;
  void clear_grin_trait_natural_id_for_vertex_type();
  bool grin_trait_natural_id_for_vertex_type() const;
  void set_grin_trait_natural_id_for_vertex_type(bool value);
  private:
  bool _internal_grin_trait_natural_id_for_vertex_type() const;
  void _internal_set_grin_trait_natural_id_for_vertex_type(bool value);
  public:

  // bool grin_trait_natural_id_for_vertex_property = 7;
  void clear_grin_trait_natural_id_for_vertex_property();
  bool grin_trait_natural_id_for_vertex_property() const;
  void set_grin_trait_natural_id_for_vertex_property(bool value);
  private:
  bool _internal_grin_trait_natural_id_for_vertex_property() const;
  void _internal_set_grin_trait_natural_id_for_vertex_property(bool value);
  public:

  // bool grin_assume_by_type_vertex_original_id = 8;
  void clear_grin_assume_by_type_vertex_original_id();
  bool grin_assume_by_type_vertex_original_id() const;
  void set_grin_assume_by_type_vertex_original_id(bool value);
  private:
  bool _internal_grin_assume_by_type_vertex_original_id() const;
  void _internal_set_grin_assume_by_type_vertex_original_id(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grin.VertexPropertyFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool grin_with_vertex_property_;
    bool grin_with_vertex_property_name_;
    bool grin_with_vertex_type_name_;
    bool grin_enable_vertex_property_table_;
    bool grin_enable_vertex_primary_keys_;
    bool grin_trait_natural_id_for_vertex_type_;
    bool grin_trait_natural_id_for_vertex_property_;
    bool grin_assume_by_type_vertex_original_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_graph_2eproto;
};
// -------------------------------------------------------------------

class EdgePropertyFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grin.EdgePropertyFeature) */ {
 public:
  inline EdgePropertyFeature() : EdgePropertyFeature(nullptr) {}
  ~EdgePropertyFeature() override;
  explicit PROTOBUF_CONSTEXPR EdgePropertyFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EdgePropertyFeature(const EdgePropertyFeature& from);
  EdgePropertyFeature(EdgePropertyFeature&& from) noexcept
    : EdgePropertyFeature() {
    *this = ::std::move(from);
  }

  inline EdgePropertyFeature& operator=(const EdgePropertyFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline EdgePropertyFeature& operator=(EdgePropertyFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EdgePropertyFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const EdgePropertyFeature* internal_default_instance() {
    return reinterpret_cast<const EdgePropertyFeature*>(
               &_EdgePropertyFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EdgePropertyFeature& a, EdgePropertyFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(EdgePropertyFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EdgePropertyFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EdgePropertyFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EdgePropertyFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EdgePropertyFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EdgePropertyFeature& from) {
    EdgePropertyFeature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgePropertyFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grin.EdgePropertyFeature";
  }
  protected:
  explicit EdgePropertyFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGrinWithEdgePropertyFieldNumber = 1,
    kGrinWithEdgePropertyNameFieldNumber = 2,
    kGrinWithEdgeTypeNameFieldNumber = 3,
    kGrinEnableEdgePropertyTableFieldNumber = 4,
    kGrinEnableEdgePrimaryKeysFieldNumber = 5,
    kGrinTraitNaturalIdForEdgeTypeFieldNumber = 6,
    kGrinTraitNaturalIdForEdgePropertyFieldNumber = 7,
  };
  // bool grin_with_edge_property = 1;
  void clear_grin_with_edge_property();
  bool grin_with_edge_property() const;
  void set_grin_with_edge_property(bool value);
  private:
  bool _internal_grin_with_edge_property() const;
  void _internal_set_grin_with_edge_property(bool value);
  public:

  // bool grin_with_edge_property_name = 2;
  void clear_grin_with_edge_property_name();
  bool grin_with_edge_property_name() const;
  void set_grin_with_edge_property_name(bool value);
  private:
  bool _internal_grin_with_edge_property_name() const;
  void _internal_set_grin_with_edge_property_name(bool value);
  public:

  // bool grin_with_edge_type_name = 3;
  void clear_grin_with_edge_type_name();
  bool grin_with_edge_type_name() const;
  void set_grin_with_edge_type_name(bool value);
  private:
  bool _internal_grin_with_edge_type_name() const;
  void _internal_set_grin_with_edge_type_name(bool value);
  public:

  // bool grin_enable_edge_property_table = 4;
  void clear_grin_enable_edge_property_table();
  bool grin_enable_edge_property_table() const;
  void set_grin_enable_edge_property_table(bool value);
  private:
  bool _internal_grin_enable_edge_property_table() const;
  void _internal_set_grin_enable_edge_property_table(bool value);
  public:

  // bool grin_enable_edge_primary_keys = 5;
  void clear_grin_enable_edge_primary_keys();
  bool grin_enable_edge_primary_keys() const;
  void set_grin_enable_edge_primary_keys(bool value);
  private:
  bool _internal_grin_enable_edge_primary_keys() const;
  void _internal_set_grin_enable_edge_primary_keys(bool value);
  public:

  // bool grin_trait_natural_id_for_edge_type = 6;
  void clear_grin_trait_natural_id_for_edge_type();
  bool grin_trait_natural_id_for_edge_type() const;
  void set_grin_trait_natural_id_for_edge_type(bool value);
  private:
  bool _internal_grin_trait_natural_id_for_edge_type() const;
  void _internal_set_grin_trait_natural_id_for_edge_type(bool value);
  public:

  // bool grin_trait_natural_id_for_edge_property = 7;
  void clear_grin_trait_natural_id_for_edge_property();
  bool grin_trait_natural_id_for_edge_property() const;
  void set_grin_trait_natural_id_for_edge_property(bool value);
  private:
  bool _internal_grin_trait_natural_id_for_edge_property() const;
  void _internal_set_grin_trait_natural_id_for_edge_property(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grin.EdgePropertyFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool grin_with_edge_property_;
    bool grin_with_edge_property_name_;
    bool grin_with_edge_type_name_;
    bool grin_enable_edge_property_table_;
    bool grin_enable_edge_primary_keys_;
    bool grin_trait_natural_id_for_edge_type_;
    bool grin_trait_natural_id_for_edge_property_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_graph_2eproto;
};
// -------------------------------------------------------------------

class PropertyFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grin.PropertyFeature) */ {
 public:
  inline PropertyFeature() : PropertyFeature(nullptr) {}
  ~PropertyFeature() override;
  explicit PROTOBUF_CONSTEXPR PropertyFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropertyFeature(const PropertyFeature& from);
  PropertyFeature(PropertyFeature&& from) noexcept
    : PropertyFeature() {
    *this = ::std::move(from);
  }

  inline PropertyFeature& operator=(const PropertyFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropertyFeature& operator=(PropertyFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropertyFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropertyFeature* internal_default_instance() {
    return reinterpret_cast<const PropertyFeature*>(
               &_PropertyFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PropertyFeature& a, PropertyFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(PropertyFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropertyFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropertyFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropertyFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropertyFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PropertyFeature& from) {
    PropertyFeature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropertyFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grin.PropertyFeature";
  }
  protected:
  explicit PropertyFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVertexPropertyFeatureFieldNumber = 2,
    kEdgePropertyFeatureFieldNumber = 3,
    kVertexPropertyFieldNumber = 4,
    kEdgePropertyFieldNumber = 5,
    kGrinEnableRowFieldNumber = 1,
    kGrinAssumeColumnStoreForVertexPropertyFieldNumber = 6,
    kGrinAssumeColumnStoreForEdgePropertyFieldNumber = 7,
    kGrinTraitSelectTypeForVertexListFieldNumber = 8,
    kGrinTraitSelectTypeForEdgeListFieldNumber = 9,
    kGrinTraitSelectNeighborTypeForAdjacentListFieldNumber = 10,
    kGrinTraitSelectEdgeTypeForAdjacentListFieldNumber = 11,
    kGrinTraitSpecificVevRelationFieldNumber = 12,
  };
  // .grin.VertexPropertyFeature vertex_property_feature = 2;
  bool has_vertex_property_feature() const;
  private:
  bool _internal_has_vertex_property_feature() const;
  public:
  void clear_vertex_property_feature();
  const ::grin::VertexPropertyFeature& vertex_property_feature() const;
  PROTOBUF_NODISCARD ::grin::VertexPropertyFeature* release_vertex_property_feature();
  ::grin::VertexPropertyFeature* mutable_vertex_property_feature();
  void set_allocated_vertex_property_feature(::grin::VertexPropertyFeature* vertex_property_feature);
  private:
  const ::grin::VertexPropertyFeature& _internal_vertex_property_feature() const;
  ::grin::VertexPropertyFeature* _internal_mutable_vertex_property_feature();
  public:
  void unsafe_arena_set_allocated_vertex_property_feature(
      ::grin::VertexPropertyFeature* vertex_property_feature);
  ::grin::VertexPropertyFeature* unsafe_arena_release_vertex_property_feature();

  // .grin.EdgePropertyFeature edge_property_feature = 3;
  bool has_edge_property_feature() const;
  private:
  bool _internal_has_edge_property_feature() const;
  public:
  void clear_edge_property_feature();
  const ::grin::EdgePropertyFeature& edge_property_feature() const;
  PROTOBUF_NODISCARD ::grin::EdgePropertyFeature* release_edge_property_feature();
  ::grin::EdgePropertyFeature* mutable_edge_property_feature();
  void set_allocated_edge_property_feature(::grin::EdgePropertyFeature* edge_property_feature);
  private:
  const ::grin::EdgePropertyFeature& _internal_edge_property_feature() const;
  ::grin::EdgePropertyFeature* _internal_mutable_edge_property_feature();
  public:
  void unsafe_arena_set_allocated_edge_property_feature(
      ::grin::EdgePropertyFeature* edge_property_feature);
  ::grin::EdgePropertyFeature* unsafe_arena_release_edge_property_feature();

  // .grin.PropertyDataPartitionStrategy vertex_property = 4;
  void clear_vertex_property();
  ::grin::PropertyDataPartitionStrategy vertex_property() const;
  void set_vertex_property(::grin::PropertyDataPartitionStrategy value);
  private:
  ::grin::PropertyDataPartitionStrategy _internal_vertex_property() const;
  void _internal_set_vertex_property(::grin::PropertyDataPartitionStrategy value);
  public:

  // .grin.PropertyDataPartitionStrategy edge_property = 5;
  void clear_edge_property();
  ::grin::PropertyDataPartitionStrategy edge_property() const;
  void set_edge_property(::grin::PropertyDataPartitionStrategy value);
  private:
  ::grin::PropertyDataPartitionStrategy _internal_edge_property() const;
  void _internal_set_edge_property(::grin::PropertyDataPartitionStrategy value);
  public:

  // bool grin_enable_row = 1;
  void clear_grin_enable_row();
  bool grin_enable_row() const;
  void set_grin_enable_row(bool value);
  private:
  bool _internal_grin_enable_row() const;
  void _internal_set_grin_enable_row(bool value);
  public:

  // bool grin_assume_column_store_for_vertex_property = 6;
  void clear_grin_assume_column_store_for_vertex_property();
  bool grin_assume_column_store_for_vertex_property() const;
  void set_grin_assume_column_store_for_vertex_property(bool value);
  private:
  bool _internal_grin_assume_column_store_for_vertex_property() const;
  void _internal_set_grin_assume_column_store_for_vertex_property(bool value);
  public:

  // bool grin_assume_column_store_for_edge_property = 7;
  void clear_grin_assume_column_store_for_edge_property();
  bool grin_assume_column_store_for_edge_property() const;
  void set_grin_assume_column_store_for_edge_property(bool value);
  private:
  bool _internal_grin_assume_column_store_for_edge_property() const;
  void _internal_set_grin_assume_column_store_for_edge_property(bool value);
  public:

  // bool grin_trait_select_type_for_vertex_list = 8;
  void clear_grin_trait_select_type_for_vertex_list();
  bool grin_trait_select_type_for_vertex_list() const;
  void set_grin_trait_select_type_for_vertex_list(bool value);
  private:
  bool _internal_grin_trait_select_type_for_vertex_list() const;
  void _internal_set_grin_trait_select_type_for_vertex_list(bool value);
  public:

  // bool grin_trait_select_type_for_edge_list = 9;
  void clear_grin_trait_select_type_for_edge_list();
  bool grin_trait_select_type_for_edge_list() const;
  void set_grin_trait_select_type_for_edge_list(bool value);
  private:
  bool _internal_grin_trait_select_type_for_edge_list() const;
  void _internal_set_grin_trait_select_type_for_edge_list(bool value);
  public:

  // bool grin_trait_select_neighbor_type_for_adjacent_list = 10;
  void clear_grin_trait_select_neighbor_type_for_adjacent_list();
  bool grin_trait_select_neighbor_type_for_adjacent_list() const;
  void set_grin_trait_select_neighbor_type_for_adjacent_list(bool value);
  private:
  bool _internal_grin_trait_select_neighbor_type_for_adjacent_list() const;
  void _internal_set_grin_trait_select_neighbor_type_for_adjacent_list(bool value);
  public:

  // bool grin_trait_select_edge_type_for_adjacent_list = 11;
  void clear_grin_trait_select_edge_type_for_adjacent_list();
  bool grin_trait_select_edge_type_for_adjacent_list() const;
  void set_grin_trait_select_edge_type_for_adjacent_list(bool value);
  private:
  bool _internal_grin_trait_select_edge_type_for_adjacent_list() const;
  void _internal_set_grin_trait_select_edge_type_for_adjacent_list(bool value);
  public:

  // bool grin_trait_specific_vev_relation = 12;
  void clear_grin_trait_specific_vev_relation();
  bool grin_trait_specific_vev_relation() const;
  void set_grin_trait_specific_vev_relation(bool value);
  private:
  bool _internal_grin_trait_specific_vev_relation() const;
  void _internal_set_grin_trait_specific_vev_relation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grin.PropertyFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::grin::VertexPropertyFeature* vertex_property_feature_;
    ::grin::EdgePropertyFeature* edge_property_feature_;
    int vertex_property_;
    int edge_property_;
    bool grin_enable_row_;
    bool grin_assume_column_store_for_vertex_property_;
    bool grin_assume_column_store_for_edge_property_;
    bool grin_trait_select_type_for_vertex_list_;
    bool grin_trait_select_type_for_edge_list_;
    bool grin_trait_select_neighbor_type_for_adjacent_list_;
    bool grin_trait_select_edge_type_for_adjacent_list_;
    bool grin_trait_specific_vev_relation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_graph_2eproto;
};
// -------------------------------------------------------------------

class IndexFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grin.IndexFeature) */ {
 public:
  inline IndexFeature() : IndexFeature(nullptr) {}
  ~IndexFeature() override;
  explicit PROTOBUF_CONSTEXPR IndexFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexFeature(const IndexFeature& from);
  IndexFeature(IndexFeature&& from) noexcept
    : IndexFeature() {
    *this = ::std::move(from);
  }

  inline IndexFeature& operator=(const IndexFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexFeature& operator=(IndexFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexFeature* internal_default_instance() {
    return reinterpret_cast<const IndexFeature*>(
               &_IndexFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IndexFeature& a, IndexFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IndexFeature& from) {
    IndexFeature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grin.IndexFeature";
  }
  protected:
  explicit IndexFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGrinWithVertexLabelFieldNumber = 1,
    kGrinWithEdgeLabelFieldNumber = 2,
    kGrinAssumeAllVertexListSortedFieldNumber = 3,
  };
  // bool grin_with_vertex_label = 1;
  void clear_grin_with_vertex_label();
  bool grin_with_vertex_label() const;
  void set_grin_with_vertex_label(bool value);
  private:
  bool _internal_grin_with_vertex_label() const;
  void _internal_set_grin_with_vertex_label(bool value);
  public:

  // bool grin_with_edge_label = 2;
  void clear_grin_with_edge_label();
  bool grin_with_edge_label() const;
  void set_grin_with_edge_label(bool value);
  private:
  bool _internal_grin_with_edge_label() const;
  void _internal_set_grin_with_edge_label(bool value);
  public:

  // bool grin_assume_all_vertex_list_sorted = 3;
  void clear_grin_assume_all_vertex_list_sorted();
  bool grin_assume_all_vertex_list_sorted() const;
  void set_grin_assume_all_vertex_list_sorted(bool value);
  private:
  bool _internal_grin_assume_all_vertex_list_sorted() const;
  void _internal_set_grin_assume_all_vertex_list_sorted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grin.IndexFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool grin_with_vertex_label_;
    bool grin_with_edge_label_;
    bool grin_assume_all_vertex_list_sorted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_graph_2eproto;
};
// -------------------------------------------------------------------

class PredicateFeature final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grin.PredicateFeature) */ {
 public:
  inline PredicateFeature() : PredicateFeature(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PredicateFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PredicateFeature(const PredicateFeature& from);
  PredicateFeature(PredicateFeature&& from) noexcept
    : PredicateFeature() {
    *this = ::std::move(from);
  }

  inline PredicateFeature& operator=(const PredicateFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredicateFeature& operator=(PredicateFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PredicateFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const PredicateFeature* internal_default_instance() {
    return reinterpret_cast<const PredicateFeature*>(
               &_PredicateFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PredicateFeature& a, PredicateFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(PredicateFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredicateFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PredicateFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PredicateFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PredicateFeature& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PredicateFeature& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grin.PredicateFeature";
  }
  protected:
  explicit PredicateFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grin.PredicateFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_graph_2eproto;
};
// -------------------------------------------------------------------

class StorageFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grin.StorageFeature) */ {
 public:
  inline StorageFeature() : StorageFeature(nullptr) {}
  ~StorageFeature() override;
  explicit PROTOBUF_CONSTEXPR StorageFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageFeature(const StorageFeature& from);
  StorageFeature(StorageFeature&& from) noexcept
    : StorageFeature() {
    *this = ::std::move(from);
  }

  inline StorageFeature& operator=(const StorageFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageFeature& operator=(StorageFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageFeature& default_instance() {
    return *internal_default_instance();
  }
  enum SpecificFeatureCase {
    kTopologyFeature = 1,
    kPartitionFeature = 2,
    kPropertyFeature = 3,
    kIndexFeature = 4,
    kPredicateFeature = 5,
    SPECIFIC_FEATURE_NOT_SET = 0,
  };

  static inline const StorageFeature* internal_default_instance() {
    return reinterpret_cast<const StorageFeature*>(
               &_StorageFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StorageFeature& a, StorageFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StorageFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StorageFeature& from) {
    StorageFeature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grin.StorageFeature";
  }
  protected:
  explicit StorageFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopologyFeatureFieldNumber = 1,
    kPartitionFeatureFieldNumber = 2,
    kPropertyFeatureFieldNumber = 3,
    kIndexFeatureFieldNumber = 4,
    kPredicateFeatureFieldNumber = 5,
  };
  // .grin.TopologyFeature topology_feature = 1;
  bool has_topology_feature() const;
  private:
  bool _internal_has_topology_feature() const;
  public:
  void clear_topology_feature();
  const ::grin::TopologyFeature& topology_feature() const;
  PROTOBUF_NODISCARD ::grin::TopologyFeature* release_topology_feature();
  ::grin::TopologyFeature* mutable_topology_feature();
  void set_allocated_topology_feature(::grin::TopologyFeature* topology_feature);
  private:
  const ::grin::TopologyFeature& _internal_topology_feature() const;
  ::grin::TopologyFeature* _internal_mutable_topology_feature();
  public:
  void unsafe_arena_set_allocated_topology_feature(
      ::grin::TopologyFeature* topology_feature);
  ::grin::TopologyFeature* unsafe_arena_release_topology_feature();

  // .grin.PartitionFeature partition_feature = 2;
  bool has_partition_feature() const;
  private:
  bool _internal_has_partition_feature() const;
  public:
  void clear_partition_feature();
  const ::grin::PartitionFeature& partition_feature() const;
  PROTOBUF_NODISCARD ::grin::PartitionFeature* release_partition_feature();
  ::grin::PartitionFeature* mutable_partition_feature();
  void set_allocated_partition_feature(::grin::PartitionFeature* partition_feature);
  private:
  const ::grin::PartitionFeature& _internal_partition_feature() const;
  ::grin::PartitionFeature* _internal_mutable_partition_feature();
  public:
  void unsafe_arena_set_allocated_partition_feature(
      ::grin::PartitionFeature* partition_feature);
  ::grin::PartitionFeature* unsafe_arena_release_partition_feature();

  // .grin.PropertyFeature property_feature = 3;
  bool has_property_feature() const;
  private:
  bool _internal_has_property_feature() const;
  public:
  void clear_property_feature();
  const ::grin::PropertyFeature& property_feature() const;
  PROTOBUF_NODISCARD ::grin::PropertyFeature* release_property_feature();
  ::grin::PropertyFeature* mutable_property_feature();
  void set_allocated_property_feature(::grin::PropertyFeature* property_feature);
  private:
  const ::grin::PropertyFeature& _internal_property_feature() const;
  ::grin::PropertyFeature* _internal_mutable_property_feature();
  public:
  void unsafe_arena_set_allocated_property_feature(
      ::grin::PropertyFeature* property_feature);
  ::grin::PropertyFeature* unsafe_arena_release_property_feature();

  // .grin.IndexFeature index_feature = 4;
  bool has_index_feature() const;
  private:
  bool _internal_has_index_feature() const;
  public:
  void clear_index_feature();
  const ::grin::IndexFeature& index_feature() const;
  PROTOBUF_NODISCARD ::grin::IndexFeature* release_index_feature();
  ::grin::IndexFeature* mutable_index_feature();
  void set_allocated_index_feature(::grin::IndexFeature* index_feature);
  private:
  const ::grin::IndexFeature& _internal_index_feature() const;
  ::grin::IndexFeature* _internal_mutable_index_feature();
  public:
  void unsafe_arena_set_allocated_index_feature(
      ::grin::IndexFeature* index_feature);
  ::grin::IndexFeature* unsafe_arena_release_index_feature();

  // .grin.PredicateFeature predicate_feature = 5;
  bool has_predicate_feature() const;
  private:
  bool _internal_has_predicate_feature() const;
  public:
  void clear_predicate_feature();
  const ::grin::PredicateFeature& predicate_feature() const;
  PROTOBUF_NODISCARD ::grin::PredicateFeature* release_predicate_feature();
  ::grin::PredicateFeature* mutable_predicate_feature();
  void set_allocated_predicate_feature(::grin::PredicateFeature* predicate_feature);
  private:
  const ::grin::PredicateFeature& _internal_predicate_feature() const;
  ::grin::PredicateFeature* _internal_mutable_predicate_feature();
  public:
  void unsafe_arena_set_allocated_predicate_feature(
      ::grin::PredicateFeature* predicate_feature);
  ::grin::PredicateFeature* unsafe_arena_release_predicate_feature();

  void clear_specific_feature();
  SpecificFeatureCase specific_feature_case() const;
  // @@protoc_insertion_point(class_scope:grin.StorageFeature)
 private:
  class _Internal;
  void set_has_topology_feature();
  void set_has_partition_feature();
  void set_has_property_feature();
  void set_has_index_feature();
  void set_has_predicate_feature();

  inline bool has_specific_feature() const;
  inline void clear_has_specific_feature();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union SpecificFeatureUnion {
      constexpr SpecificFeatureUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::grin::TopologyFeature* topology_feature_;
      ::grin::PartitionFeature* partition_feature_;
      ::grin::PropertyFeature* property_feature_;
      ::grin::IndexFeature* index_feature_;
      ::grin::PredicateFeature* predicate_feature_;
    } specific_feature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_graph_2eproto;
};
// -------------------------------------------------------------------

class Statistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grin.Statistics) */ {
 public:
  inline Statistics() : Statistics(nullptr) {}
  ~Statistics() override;
  explicit PROTOBUF_CONSTEXPR Statistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Statistics(const Statistics& from);
  Statistics(Statistics&& from) noexcept
    : Statistics() {
    *this = ::std::move(from);
  }

  inline Statistics& operator=(const Statistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statistics& operator=(Statistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const Statistics* internal_default_instance() {
    return reinterpret_cast<const Statistics*>(
               &_Statistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Statistics& a, Statistics& b) {
    a.Swap(&b);
  }
  inline void Swap(Statistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Statistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Statistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Statistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Statistics& from) {
    Statistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grin.Statistics";
  }
  protected:
  explicit Statistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVertexCountFieldNumber = 1,
    kEdgeCountFieldNumber = 2,
    kPartitionCountFieldNumber = 3,
    kVertexTypeCountFieldNumber = 4,
    kEdgeTypeCountFieldNumber = 5,
  };
  // int32 vertex_count = 1;
  void clear_vertex_count();
  int32_t vertex_count() const;
  void set_vertex_count(int32_t value);
  private:
  int32_t _internal_vertex_count() const;
  void _internal_set_vertex_count(int32_t value);
  public:

  // int32 edge_count = 2;
  void clear_edge_count();
  int32_t edge_count() const;
  void set_edge_count(int32_t value);
  private:
  int32_t _internal_edge_count() const;
  void _internal_set_edge_count(int32_t value);
  public:

  // int32 partition_count = 3;
  void clear_partition_count();
  int32_t partition_count() const;
  void set_partition_count(int32_t value);
  private:
  int32_t _internal_partition_count() const;
  void _internal_set_partition_count(int32_t value);
  public:

  // int32 vertex_type_count = 4;
  void clear_vertex_type_count();
  int32_t vertex_type_count() const;
  void set_vertex_type_count(int32_t value);
  private:
  int32_t _internal_vertex_type_count() const;
  void _internal_set_vertex_type_count(int32_t value);
  public:

  // int32 edge_type_count = 5;
  void clear_edge_type_count();
  int32_t edge_type_count() const;
  void set_edge_type_count(int32_t value);
  private:
  int32_t _internal_edge_type_count() const;
  void _internal_set_edge_type_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grin.Statistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t vertex_count_;
    int32_t edge_count_;
    int32_t partition_count_;
    int32_t vertex_type_count_;
    int32_t edge_type_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_graph_2eproto;
};
// -------------------------------------------------------------------

class Graph final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grin.Graph) */ {
 public:
  inline Graph() : Graph(nullptr) {}
  ~Graph() override;
  explicit PROTOBUF_CONSTEXPR Graph(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Graph(const Graph& from);
  Graph(Graph&& from) noexcept
    : Graph() {
    *this = ::std::move(from);
  }

  inline Graph& operator=(const Graph& from) {
    CopyFrom(from);
    return *this;
  }
  inline Graph& operator=(Graph&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Graph& default_instance() {
    return *internal_default_instance();
  }
  static inline const Graph* internal_default_instance() {
    return reinterpret_cast<const Graph*>(
               &_Graph_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Graph& a, Graph& b) {
    a.Swap(&b);
  }
  inline void Swap(Graph* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Graph* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Graph* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Graph>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Graph& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Graph& from) {
    Graph::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Graph* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grin.Graph";
  }
  protected:
  explicit Graph(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeaturesFieldNumber = 3,
    kUriFieldNumber = 1,
    kGrinVersionFieldNumber = 2,
    kStatisticsFieldNumber = 4,
  };
  // repeated .grin.StorageFeature features = 3;
  int features_size() const;
  private:
  int _internal_features_size() const;
  public:
  void clear_features();
  ::grin::StorageFeature* mutable_features(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grin::StorageFeature >*
      mutable_features();
  private:
  const ::grin::StorageFeature& _internal_features(int index) const;
  ::grin::StorageFeature* _internal_add_features();
  public:
  const ::grin::StorageFeature& features(int index) const;
  ::grin::StorageFeature* add_features();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grin::StorageFeature >&
      features() const;

  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string grin_version = 2;
  void clear_grin_version();
  const std::string& grin_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_grin_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_grin_version();
  PROTOBUF_NODISCARD std::string* release_grin_version();
  void set_allocated_grin_version(std::string* grin_version);
  private:
  const std::string& _internal_grin_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_grin_version(const std::string& value);
  std::string* _internal_mutable_grin_version();
  public:

  // .grin.Statistics statistics = 4;
  bool has_statistics() const;
  private:
  bool _internal_has_statistics() const;
  public:
  void clear_statistics();
  const ::grin::Statistics& statistics() const;
  PROTOBUF_NODISCARD ::grin::Statistics* release_statistics();
  ::grin::Statistics* mutable_statistics();
  void set_allocated_statistics(::grin::Statistics* statistics);
  private:
  const ::grin::Statistics& _internal_statistics() const;
  ::grin::Statistics* _internal_mutable_statistics();
  public:
  void unsafe_arena_set_allocated_statistics(
      ::grin::Statistics* statistics);
  ::grin::Statistics* unsafe_arena_release_statistics();

  // @@protoc_insertion_point(class_scope:grin.Graph)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grin::StorageFeature > features_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr grin_version_;
    ::grin::Statistics* statistics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_graph_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TopologyFeature

// bool grin_assume_has_directed_graph = 1;
inline void TopologyFeature::clear_grin_assume_has_directed_graph() {
  _impl_.grin_assume_has_directed_graph_ = false;
}
inline bool TopologyFeature::_internal_grin_assume_has_directed_graph() const {
  return _impl_.grin_assume_has_directed_graph_;
}
inline bool TopologyFeature::grin_assume_has_directed_graph() const {
  // @@protoc_insertion_point(field_get:grin.TopologyFeature.grin_assume_has_directed_graph)
  return _internal_grin_assume_has_directed_graph();
}
inline void TopologyFeature::_internal_set_grin_assume_has_directed_graph(bool value) {
  
  _impl_.grin_assume_has_directed_graph_ = value;
}
inline void TopologyFeature::set_grin_assume_has_directed_graph(bool value) {
  _internal_set_grin_assume_has_directed_graph(value);
  // @@protoc_insertion_point(field_set:grin.TopologyFeature.grin_assume_has_directed_graph)
}

// bool grin_assume_has_undirected_graph = 2;
inline void TopologyFeature::clear_grin_assume_has_undirected_graph() {
  _impl_.grin_assume_has_undirected_graph_ = false;
}
inline bool TopologyFeature::_internal_grin_assume_has_undirected_graph() const {
  return _impl_.grin_assume_has_undirected_graph_;
}
inline bool TopologyFeature::grin_assume_has_undirected_graph() const {
  // @@protoc_insertion_point(field_get:grin.TopologyFeature.grin_assume_has_undirected_graph)
  return _internal_grin_assume_has_undirected_graph();
}
inline void TopologyFeature::_internal_set_grin_assume_has_undirected_graph(bool value) {
  
  _impl_.grin_assume_has_undirected_graph_ = value;
}
inline void TopologyFeature::set_grin_assume_has_undirected_graph(bool value) {
  _internal_set_grin_assume_has_undirected_graph(value);
  // @@protoc_insertion_point(field_set:grin.TopologyFeature.grin_assume_has_undirected_graph)
}

// bool grin_assume_has_multi_edge_graph = 3;
inline void TopologyFeature::clear_grin_assume_has_multi_edge_graph() {
  _impl_.grin_assume_has_multi_edge_graph_ = false;
}
inline bool TopologyFeature::_internal_grin_assume_has_multi_edge_graph() const {
  return _impl_.grin_assume_has_multi_edge_graph_;
}
inline bool TopologyFeature::grin_assume_has_multi_edge_graph() const {
  // @@protoc_insertion_point(field_get:grin.TopologyFeature.grin_assume_has_multi_edge_graph)
  return _internal_grin_assume_has_multi_edge_graph();
}
inline void TopologyFeature::_internal_set_grin_assume_has_multi_edge_graph(bool value) {
  
  _impl_.grin_assume_has_multi_edge_graph_ = value;
}
inline void TopologyFeature::set_grin_assume_has_multi_edge_graph(bool value) {
  _internal_set_grin_assume_has_multi_edge_graph(value);
  // @@protoc_insertion_point(field_set:grin.TopologyFeature.grin_assume_has_multi_edge_graph)
}

// bool grin_with_vertex_original_id = 4;
inline void TopologyFeature::clear_grin_with_vertex_original_id() {
  _impl_.grin_with_vertex_original_id_ = false;
}
inline bool TopologyFeature::_internal_grin_with_vertex_original_id() const {
  return _impl_.grin_with_vertex_original_id_;
}
inline bool TopologyFeature::grin_with_vertex_original_id() const {
  // @@protoc_insertion_point(field_get:grin.TopologyFeature.grin_with_vertex_original_id)
  return _internal_grin_with_vertex_original_id();
}
inline void TopologyFeature::_internal_set_grin_with_vertex_original_id(bool value) {
  
  _impl_.grin_with_vertex_original_id_ = value;
}
inline void TopologyFeature::set_grin_with_vertex_original_id(bool value) {
  _internal_set_grin_with_vertex_original_id(value);
  // @@protoc_insertion_point(field_set:grin.TopologyFeature.grin_with_vertex_original_id)
}

// bool grin_with_vertex_data = 5;
inline void TopologyFeature::clear_grin_with_vertex_data() {
  _impl_.grin_with_vertex_data_ = false;
}
inline bool TopologyFeature::_internal_grin_with_vertex_data() const {
  return _impl_.grin_with_vertex_data_;
}
inline bool TopologyFeature::grin_with_vertex_data() const {
  // @@protoc_insertion_point(field_get:grin.TopologyFeature.grin_with_vertex_data)
  return _internal_grin_with_vertex_data();
}
inline void TopologyFeature::_internal_set_grin_with_vertex_data(bool value) {
  
  _impl_.grin_with_vertex_data_ = value;
}
inline void TopologyFeature::set_grin_with_vertex_data(bool value) {
  _internal_set_grin_with_vertex_data(value);
  // @@protoc_insertion_point(field_set:grin.TopologyFeature.grin_with_vertex_data)
}

// bool grin_with_edge_data = 6;
inline void TopologyFeature::clear_grin_with_edge_data() {
  _impl_.grin_with_edge_data_ = false;
}
inline bool TopologyFeature::_internal_grin_with_edge_data() const {
  return _impl_.grin_with_edge_data_;
}
inline bool TopologyFeature::grin_with_edge_data() const {
  // @@protoc_insertion_point(field_get:grin.TopologyFeature.grin_with_edge_data)
  return _internal_grin_with_edge_data();
}
inline void TopologyFeature::_internal_set_grin_with_edge_data(bool value) {
  
  _impl_.grin_with_edge_data_ = value;
}
inline void TopologyFeature::set_grin_with_edge_data(bool value) {
  _internal_set_grin_with_edge_data(value);
  // @@protoc_insertion_point(field_set:grin.TopologyFeature.grin_with_edge_data)
}

// repeated .grin.ListRetrieval vertex_list_retrievals = 7;
inline int TopologyFeature::_internal_vertex_list_retrievals_size() const {
  return _impl_.vertex_list_retrievals_.size();
}
inline int TopologyFeature::vertex_list_retrievals_size() const {
  return _internal_vertex_list_retrievals_size();
}
inline void TopologyFeature::clear_vertex_list_retrievals() {
  _impl_.vertex_list_retrievals_.Clear();
}
inline ::grin::ListRetrieval TopologyFeature::_internal_vertex_list_retrievals(int index) const {
  return static_cast< ::grin::ListRetrieval >(_impl_.vertex_list_retrievals_.Get(index));
}
inline ::grin::ListRetrieval TopologyFeature::vertex_list_retrievals(int index) const {
  // @@protoc_insertion_point(field_get:grin.TopologyFeature.vertex_list_retrievals)
  return _internal_vertex_list_retrievals(index);
}
inline void TopologyFeature::set_vertex_list_retrievals(int index, ::grin::ListRetrieval value) {
  _impl_.vertex_list_retrievals_.Set(index, value);
  // @@protoc_insertion_point(field_set:grin.TopologyFeature.vertex_list_retrievals)
}
inline void TopologyFeature::_internal_add_vertex_list_retrievals(::grin::ListRetrieval value) {
  _impl_.vertex_list_retrievals_.Add(value);
}
inline void TopologyFeature::add_vertex_list_retrievals(::grin::ListRetrieval value) {
  _internal_add_vertex_list_retrievals(value);
  // @@protoc_insertion_point(field_add:grin.TopologyFeature.vertex_list_retrievals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TopologyFeature::vertex_list_retrievals() const {
  // @@protoc_insertion_point(field_list:grin.TopologyFeature.vertex_list_retrievals)
  return _impl_.vertex_list_retrievals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TopologyFeature::_internal_mutable_vertex_list_retrievals() {
  return &_impl_.vertex_list_retrievals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TopologyFeature::mutable_vertex_list_retrievals() {
  // @@protoc_insertion_point(field_mutable_list:grin.TopologyFeature.vertex_list_retrievals)
  return _internal_mutable_vertex_list_retrievals();
}

// repeated .grin.ListRetrieval edge_list_retrievals = 8;
inline int TopologyFeature::_internal_edge_list_retrievals_size() const {
  return _impl_.edge_list_retrievals_.size();
}
inline int TopologyFeature::edge_list_retrievals_size() const {
  return _internal_edge_list_retrievals_size();
}
inline void TopologyFeature::clear_edge_list_retrievals() {
  _impl_.edge_list_retrievals_.Clear();
}
inline ::grin::ListRetrieval TopologyFeature::_internal_edge_list_retrievals(int index) const {
  return static_cast< ::grin::ListRetrieval >(_impl_.edge_list_retrievals_.Get(index));
}
inline ::grin::ListRetrieval TopologyFeature::edge_list_retrievals(int index) const {
  // @@protoc_insertion_point(field_get:grin.TopologyFeature.edge_list_retrievals)
  return _internal_edge_list_retrievals(index);
}
inline void TopologyFeature::set_edge_list_retrievals(int index, ::grin::ListRetrieval value) {
  _impl_.edge_list_retrievals_.Set(index, value);
  // @@protoc_insertion_point(field_set:grin.TopologyFeature.edge_list_retrievals)
}
inline void TopologyFeature::_internal_add_edge_list_retrievals(::grin::ListRetrieval value) {
  _impl_.edge_list_retrievals_.Add(value);
}
inline void TopologyFeature::add_edge_list_retrievals(::grin::ListRetrieval value) {
  _internal_add_edge_list_retrievals(value);
  // @@protoc_insertion_point(field_add:grin.TopologyFeature.edge_list_retrievals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TopologyFeature::edge_list_retrievals() const {
  // @@protoc_insertion_point(field_list:grin.TopologyFeature.edge_list_retrievals)
  return _impl_.edge_list_retrievals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TopologyFeature::_internal_mutable_edge_list_retrievals() {
  return &_impl_.edge_list_retrievals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TopologyFeature::mutable_edge_list_retrievals() {
  // @@protoc_insertion_point(field_mutable_list:grin.TopologyFeature.edge_list_retrievals)
  return _internal_mutable_edge_list_retrievals();
}

// repeated .grin.ListRetrieval adjacent_list_retrievals = 9;
inline int TopologyFeature::_internal_adjacent_list_retrievals_size() const {
  return _impl_.adjacent_list_retrievals_.size();
}
inline int TopologyFeature::adjacent_list_retrievals_size() const {
  return _internal_adjacent_list_retrievals_size();
}
inline void TopologyFeature::clear_adjacent_list_retrievals() {
  _impl_.adjacent_list_retrievals_.Clear();
}
inline ::grin::ListRetrieval TopologyFeature::_internal_adjacent_list_retrievals(int index) const {
  return static_cast< ::grin::ListRetrieval >(_impl_.adjacent_list_retrievals_.Get(index));
}
inline ::grin::ListRetrieval TopologyFeature::adjacent_list_retrievals(int index) const {
  // @@protoc_insertion_point(field_get:grin.TopologyFeature.adjacent_list_retrievals)
  return _internal_adjacent_list_retrievals(index);
}
inline void TopologyFeature::set_adjacent_list_retrievals(int index, ::grin::ListRetrieval value) {
  _impl_.adjacent_list_retrievals_.Set(index, value);
  // @@protoc_insertion_point(field_set:grin.TopologyFeature.adjacent_list_retrievals)
}
inline void TopologyFeature::_internal_add_adjacent_list_retrievals(::grin::ListRetrieval value) {
  _impl_.adjacent_list_retrievals_.Add(value);
}
inline void TopologyFeature::add_adjacent_list_retrievals(::grin::ListRetrieval value) {
  _internal_add_adjacent_list_retrievals(value);
  // @@protoc_insertion_point(field_add:grin.TopologyFeature.adjacent_list_retrievals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TopologyFeature::adjacent_list_retrievals() const {
  // @@protoc_insertion_point(field_list:grin.TopologyFeature.adjacent_list_retrievals)
  return _impl_.adjacent_list_retrievals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TopologyFeature::_internal_mutable_adjacent_list_retrievals() {
  return &_impl_.adjacent_list_retrievals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TopologyFeature::mutable_adjacent_list_retrievals() {
  // @@protoc_insertion_point(field_mutable_list:grin.TopologyFeature.adjacent_list_retrievals)
  return _internal_mutable_adjacent_list_retrievals();
}

// -------------------------------------------------------------------

// MirrorPartitionListFeature

// bool grin_trait_master_vertex_mirror_partition_list = 1;
inline void MirrorPartitionListFeature::clear_grin_trait_master_vertex_mirror_partition_list() {
  _impl_.grin_trait_master_vertex_mirror_partition_list_ = false;
}
inline bool MirrorPartitionListFeature::_internal_grin_trait_master_vertex_mirror_partition_list() const {
  return _impl_.grin_trait_master_vertex_mirror_partition_list_;
}
inline bool MirrorPartitionListFeature::grin_trait_master_vertex_mirror_partition_list() const {
  // @@protoc_insertion_point(field_get:grin.MirrorPartitionListFeature.grin_trait_master_vertex_mirror_partition_list)
  return _internal_grin_trait_master_vertex_mirror_partition_list();
}
inline void MirrorPartitionListFeature::_internal_set_grin_trait_master_vertex_mirror_partition_list(bool value) {
  
  _impl_.grin_trait_master_vertex_mirror_partition_list_ = value;
}
inline void MirrorPartitionListFeature::set_grin_trait_master_vertex_mirror_partition_list(bool value) {
  _internal_set_grin_trait_master_vertex_mirror_partition_list(value);
  // @@protoc_insertion_point(field_set:grin.MirrorPartitionListFeature.grin_trait_master_vertex_mirror_partition_list)
}

// bool grin_trait_mirror_vertex_mirror_partition_list = 2;
inline void MirrorPartitionListFeature::clear_grin_trait_mirror_vertex_mirror_partition_list() {
  _impl_.grin_trait_mirror_vertex_mirror_partition_list_ = false;
}
inline bool MirrorPartitionListFeature::_internal_grin_trait_mirror_vertex_mirror_partition_list() const {
  return _impl_.grin_trait_mirror_vertex_mirror_partition_list_;
}
inline bool MirrorPartitionListFeature::grin_trait_mirror_vertex_mirror_partition_list() const {
  // @@protoc_insertion_point(field_get:grin.MirrorPartitionListFeature.grin_trait_mirror_vertex_mirror_partition_list)
  return _internal_grin_trait_mirror_vertex_mirror_partition_list();
}
inline void MirrorPartitionListFeature::_internal_set_grin_trait_mirror_vertex_mirror_partition_list(bool value) {
  
  _impl_.grin_trait_mirror_vertex_mirror_partition_list_ = value;
}
inline void MirrorPartitionListFeature::set_grin_trait_mirror_vertex_mirror_partition_list(bool value) {
  _internal_set_grin_trait_mirror_vertex_mirror_partition_list(value);
  // @@protoc_insertion_point(field_set:grin.MirrorPartitionListFeature.grin_trait_mirror_vertex_mirror_partition_list)
}

// bool grin_trait_master_edge_mirror_partition_list = 3;
inline void MirrorPartitionListFeature::clear_grin_trait_master_edge_mirror_partition_list() {
  _impl_.grin_trait_master_edge_mirror_partition_list_ = false;
}
inline bool MirrorPartitionListFeature::_internal_grin_trait_master_edge_mirror_partition_list() const {
  return _impl_.grin_trait_master_edge_mirror_partition_list_;
}
inline bool MirrorPartitionListFeature::grin_trait_master_edge_mirror_partition_list() const {
  // @@protoc_insertion_point(field_get:grin.MirrorPartitionListFeature.grin_trait_master_edge_mirror_partition_list)
  return _internal_grin_trait_master_edge_mirror_partition_list();
}
inline void MirrorPartitionListFeature::_internal_set_grin_trait_master_edge_mirror_partition_list(bool value) {
  
  _impl_.grin_trait_master_edge_mirror_partition_list_ = value;
}
inline void MirrorPartitionListFeature::set_grin_trait_master_edge_mirror_partition_list(bool value) {
  _internal_set_grin_trait_master_edge_mirror_partition_list(value);
  // @@protoc_insertion_point(field_set:grin.MirrorPartitionListFeature.grin_trait_master_edge_mirror_partition_list)
}

// bool grin_trait_mirror_edge_mirror_partition_list = 4;
inline void MirrorPartitionListFeature::clear_grin_trait_mirror_edge_mirror_partition_list() {
  _impl_.grin_trait_mirror_edge_mirror_partition_list_ = false;
}
inline bool MirrorPartitionListFeature::_internal_grin_trait_mirror_edge_mirror_partition_list() const {
  return _impl_.grin_trait_mirror_edge_mirror_partition_list_;
}
inline bool MirrorPartitionListFeature::grin_trait_mirror_edge_mirror_partition_list() const {
  // @@protoc_insertion_point(field_get:grin.MirrorPartitionListFeature.grin_trait_mirror_edge_mirror_partition_list)
  return _internal_grin_trait_mirror_edge_mirror_partition_list();
}
inline void MirrorPartitionListFeature::_internal_set_grin_trait_mirror_edge_mirror_partition_list(bool value) {
  
  _impl_.grin_trait_mirror_edge_mirror_partition_list_ = value;
}
inline void MirrorPartitionListFeature::set_grin_trait_mirror_edge_mirror_partition_list(bool value) {
  _internal_set_grin_trait_mirror_edge_mirror_partition_list(value);
  // @@protoc_insertion_point(field_set:grin.MirrorPartitionListFeature.grin_trait_mirror_edge_mirror_partition_list)
}

// -------------------------------------------------------------------

// PartitionFeature

// .grin.GraphPartitionStrategy graph_partition_strategy = 1;
inline void PartitionFeature::clear_graph_partition_strategy() {
  _impl_.graph_partition_strategy_ = 0;
}
inline ::grin::GraphPartitionStrategy PartitionFeature::_internal_graph_partition_strategy() const {
  return static_cast< ::grin::GraphPartitionStrategy >(_impl_.graph_partition_strategy_);
}
inline ::grin::GraphPartitionStrategy PartitionFeature::graph_partition_strategy() const {
  // @@protoc_insertion_point(field_get:grin.PartitionFeature.graph_partition_strategy)
  return _internal_graph_partition_strategy();
}
inline void PartitionFeature::_internal_set_graph_partition_strategy(::grin::GraphPartitionStrategy value) {
  
  _impl_.graph_partition_strategy_ = value;
}
inline void PartitionFeature::set_graph_partition_strategy(::grin::GraphPartitionStrategy value) {
  _internal_set_graph_partition_strategy(value);
  // @@protoc_insertion_point(field_set:grin.PartitionFeature.graph_partition_strategy)
}

// bool grin_trait_natural_id_for_partition = 2;
inline void PartitionFeature::clear_grin_trait_natural_id_for_partition() {
  _impl_.grin_trait_natural_id_for_partition_ = false;
}
inline bool PartitionFeature::_internal_grin_trait_natural_id_for_partition() const {
  return _impl_.grin_trait_natural_id_for_partition_;
}
inline bool PartitionFeature::grin_trait_natural_id_for_partition() const {
  // @@protoc_insertion_point(field_get:grin.PartitionFeature.grin_trait_natural_id_for_partition)
  return _internal_grin_trait_natural_id_for_partition();
}
inline void PartitionFeature::_internal_set_grin_trait_natural_id_for_partition(bool value) {
  
  _impl_.grin_trait_natural_id_for_partition_ = value;
}
inline void PartitionFeature::set_grin_trait_natural_id_for_partition(bool value) {
  _internal_set_grin_trait_natural_id_for_partition(value);
  // @@protoc_insertion_point(field_set:grin.PartitionFeature.grin_trait_natural_id_for_partition)
}

// bool grin_enable_vertex_ref = 3;
inline void PartitionFeature::clear_grin_enable_vertex_ref() {
  _impl_.grin_enable_vertex_ref_ = false;
}
inline bool PartitionFeature::_internal_grin_enable_vertex_ref() const {
  return _impl_.grin_enable_vertex_ref_;
}
inline bool PartitionFeature::grin_enable_vertex_ref() const {
  // @@protoc_insertion_point(field_get:grin.PartitionFeature.grin_enable_vertex_ref)
  return _internal_grin_enable_vertex_ref();
}
inline void PartitionFeature::_internal_set_grin_enable_vertex_ref(bool value) {
  
  _impl_.grin_enable_vertex_ref_ = value;
}
inline void PartitionFeature::set_grin_enable_vertex_ref(bool value) {
  _internal_set_grin_enable_vertex_ref(value);
  // @@protoc_insertion_point(field_set:grin.PartitionFeature.grin_enable_vertex_ref)
}

// bool grin_enable_edge_ref = 4;
inline void PartitionFeature::clear_grin_enable_edge_ref() {
  _impl_.grin_enable_edge_ref_ = false;
}
inline bool PartitionFeature::_internal_grin_enable_edge_ref() const {
  return _impl_.grin_enable_edge_ref_;
}
inline bool PartitionFeature::grin_enable_edge_ref() const {
  // @@protoc_insertion_point(field_get:grin.PartitionFeature.grin_enable_edge_ref)
  return _internal_grin_enable_edge_ref();
}
inline void PartitionFeature::_internal_set_grin_enable_edge_ref(bool value) {
  
  _impl_.grin_enable_edge_ref_ = value;
}
inline void PartitionFeature::set_grin_enable_edge_ref(bool value) {
  _internal_set_grin_enable_edge_ref(value);
  // @@protoc_insertion_point(field_set:grin.PartitionFeature.grin_enable_edge_ref)
}

// .grin.PropertyDataPartitionStrategy vertex_data = 5;
inline void PartitionFeature::clear_vertex_data() {
  _impl_.vertex_data_ = 0;
}
inline ::grin::PropertyDataPartitionStrategy PartitionFeature::_internal_vertex_data() const {
  return static_cast< ::grin::PropertyDataPartitionStrategy >(_impl_.vertex_data_);
}
inline ::grin::PropertyDataPartitionStrategy PartitionFeature::vertex_data() const {
  // @@protoc_insertion_point(field_get:grin.PartitionFeature.vertex_data)
  return _internal_vertex_data();
}
inline void PartitionFeature::_internal_set_vertex_data(::grin::PropertyDataPartitionStrategy value) {
  
  _impl_.vertex_data_ = value;
}
inline void PartitionFeature::set_vertex_data(::grin::PropertyDataPartitionStrategy value) {
  _internal_set_vertex_data(value);
  // @@protoc_insertion_point(field_set:grin.PartitionFeature.vertex_data)
}

// .grin.PropertyDataPartitionStrategy edge_data = 6;
inline void PartitionFeature::clear_edge_data() {
  _impl_.edge_data_ = 0;
}
inline ::grin::PropertyDataPartitionStrategy PartitionFeature::_internal_edge_data() const {
  return static_cast< ::grin::PropertyDataPartitionStrategy >(_impl_.edge_data_);
}
inline ::grin::PropertyDataPartitionStrategy PartitionFeature::edge_data() const {
  // @@protoc_insertion_point(field_get:grin.PartitionFeature.edge_data)
  return _internal_edge_data();
}
inline void PartitionFeature::_internal_set_edge_data(::grin::PropertyDataPartitionStrategy value) {
  
  _impl_.edge_data_ = value;
}
inline void PartitionFeature::set_edge_data(::grin::PropertyDataPartitionStrategy value) {
  _internal_set_edge_data(value);
  // @@protoc_insertion_point(field_set:grin.PartitionFeature.edge_data)
}

// .grin.MirrorPartitionListFeature mirror_partition_list_feature = 7;
inline bool PartitionFeature::_internal_has_mirror_partition_list_feature() const {
  return this != internal_default_instance() && _impl_.mirror_partition_list_feature_ != nullptr;
}
inline bool PartitionFeature::has_mirror_partition_list_feature() const {
  return _internal_has_mirror_partition_list_feature();
}
inline void PartitionFeature::clear_mirror_partition_list_feature() {
  if (GetArenaForAllocation() == nullptr && _impl_.mirror_partition_list_feature_ != nullptr) {
    delete _impl_.mirror_partition_list_feature_;
  }
  _impl_.mirror_partition_list_feature_ = nullptr;
}
inline const ::grin::MirrorPartitionListFeature& PartitionFeature::_internal_mirror_partition_list_feature() const {
  const ::grin::MirrorPartitionListFeature* p = _impl_.mirror_partition_list_feature_;
  return p != nullptr ? *p : reinterpret_cast<const ::grin::MirrorPartitionListFeature&>(
      ::grin::_MirrorPartitionListFeature_default_instance_);
}
inline const ::grin::MirrorPartitionListFeature& PartitionFeature::mirror_partition_list_feature() const {
  // @@protoc_insertion_point(field_get:grin.PartitionFeature.mirror_partition_list_feature)
  return _internal_mirror_partition_list_feature();
}
inline void PartitionFeature::unsafe_arena_set_allocated_mirror_partition_list_feature(
    ::grin::MirrorPartitionListFeature* mirror_partition_list_feature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mirror_partition_list_feature_);
  }
  _impl_.mirror_partition_list_feature_ = mirror_partition_list_feature;
  if (mirror_partition_list_feature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grin.PartitionFeature.mirror_partition_list_feature)
}
inline ::grin::MirrorPartitionListFeature* PartitionFeature::release_mirror_partition_list_feature() {
  
  ::grin::MirrorPartitionListFeature* temp = _impl_.mirror_partition_list_feature_;
  _impl_.mirror_partition_list_feature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grin::MirrorPartitionListFeature* PartitionFeature::unsafe_arena_release_mirror_partition_list_feature() {
  // @@protoc_insertion_point(field_release:grin.PartitionFeature.mirror_partition_list_feature)
  
  ::grin::MirrorPartitionListFeature* temp = _impl_.mirror_partition_list_feature_;
  _impl_.mirror_partition_list_feature_ = nullptr;
  return temp;
}
inline ::grin::MirrorPartitionListFeature* PartitionFeature::_internal_mutable_mirror_partition_list_feature() {
  
  if (_impl_.mirror_partition_list_feature_ == nullptr) {
    auto* p = CreateMaybeMessage<::grin::MirrorPartitionListFeature>(GetArenaForAllocation());
    _impl_.mirror_partition_list_feature_ = p;
  }
  return _impl_.mirror_partition_list_feature_;
}
inline ::grin::MirrorPartitionListFeature* PartitionFeature::mutable_mirror_partition_list_feature() {
  ::grin::MirrorPartitionListFeature* _msg = _internal_mutable_mirror_partition_list_feature();
  // @@protoc_insertion_point(field_mutable:grin.PartitionFeature.mirror_partition_list_feature)
  return _msg;
}
inline void PartitionFeature::set_allocated_mirror_partition_list_feature(::grin::MirrorPartitionListFeature* mirror_partition_list_feature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mirror_partition_list_feature_;
  }
  if (mirror_partition_list_feature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mirror_partition_list_feature);
    if (message_arena != submessage_arena) {
      mirror_partition_list_feature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mirror_partition_list_feature, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mirror_partition_list_feature_ = mirror_partition_list_feature;
  // @@protoc_insertion_point(field_set_allocated:grin.PartitionFeature.mirror_partition_list_feature)
}

// bool grin_trait_select_master_for_vertex_list = 8;
inline void PartitionFeature::clear_grin_trait_select_master_for_vertex_list() {
  _impl_.grin_trait_select_master_for_vertex_list_ = false;
}
inline bool PartitionFeature::_internal_grin_trait_select_master_for_vertex_list() const {
  return _impl_.grin_trait_select_master_for_vertex_list_;
}
inline bool PartitionFeature::grin_trait_select_master_for_vertex_list() const {
  // @@protoc_insertion_point(field_get:grin.PartitionFeature.grin_trait_select_master_for_vertex_list)
  return _internal_grin_trait_select_master_for_vertex_list();
}
inline void PartitionFeature::_internal_set_grin_trait_select_master_for_vertex_list(bool value) {
  
  _impl_.grin_trait_select_master_for_vertex_list_ = value;
}
inline void PartitionFeature::set_grin_trait_select_master_for_vertex_list(bool value) {
  _internal_set_grin_trait_select_master_for_vertex_list(value);
  // @@protoc_insertion_point(field_set:grin.PartitionFeature.grin_trait_select_master_for_vertex_list)
}

// bool grin_trait_select_partition_for_vertex_list = 9;
inline void PartitionFeature::clear_grin_trait_select_partition_for_vertex_list() {
  _impl_.grin_trait_select_partition_for_vertex_list_ = false;
}
inline bool PartitionFeature::_internal_grin_trait_select_partition_for_vertex_list() const {
  return _impl_.grin_trait_select_partition_for_vertex_list_;
}
inline bool PartitionFeature::grin_trait_select_partition_for_vertex_list() const {
  // @@protoc_insertion_point(field_get:grin.PartitionFeature.grin_trait_select_partition_for_vertex_list)
  return _internal_grin_trait_select_partition_for_vertex_list();
}
inline void PartitionFeature::_internal_set_grin_trait_select_partition_for_vertex_list(bool value) {
  
  _impl_.grin_trait_select_partition_for_vertex_list_ = value;
}
inline void PartitionFeature::set_grin_trait_select_partition_for_vertex_list(bool value) {
  _internal_set_grin_trait_select_partition_for_vertex_list(value);
  // @@protoc_insertion_point(field_set:grin.PartitionFeature.grin_trait_select_partition_for_vertex_list)
}

// bool grin_trait_select_master_for_edge_list = 10;
inline void PartitionFeature::clear_grin_trait_select_master_for_edge_list() {
  _impl_.grin_trait_select_master_for_edge_list_ = false;
}
inline bool PartitionFeature::_internal_grin_trait_select_master_for_edge_list() const {
  return _impl_.grin_trait_select_master_for_edge_list_;
}
inline bool PartitionFeature::grin_trait_select_master_for_edge_list() const {
  // @@protoc_insertion_point(field_get:grin.PartitionFeature.grin_trait_select_master_for_edge_list)
  return _internal_grin_trait_select_master_for_edge_list();
}
inline void PartitionFeature::_internal_set_grin_trait_select_master_for_edge_list(bool value) {
  
  _impl_.grin_trait_select_master_for_edge_list_ = value;
}
inline void PartitionFeature::set_grin_trait_select_master_for_edge_list(bool value) {
  _internal_set_grin_trait_select_master_for_edge_list(value);
  // @@protoc_insertion_point(field_set:grin.PartitionFeature.grin_trait_select_master_for_edge_list)
}

// bool grin_trait_select_partition_for_edge_list = 11;
inline void PartitionFeature::clear_grin_trait_select_partition_for_edge_list() {
  _impl_.grin_trait_select_partition_for_edge_list_ = false;
}
inline bool PartitionFeature::_internal_grin_trait_select_partition_for_edge_list() const {
  return _impl_.grin_trait_select_partition_for_edge_list_;
}
inline bool PartitionFeature::grin_trait_select_partition_for_edge_list() const {
  // @@protoc_insertion_point(field_get:grin.PartitionFeature.grin_trait_select_partition_for_edge_list)
  return _internal_grin_trait_select_partition_for_edge_list();
}
inline void PartitionFeature::_internal_set_grin_trait_select_partition_for_edge_list(bool value) {
  
  _impl_.grin_trait_select_partition_for_edge_list_ = value;
}
inline void PartitionFeature::set_grin_trait_select_partition_for_edge_list(bool value) {
  _internal_set_grin_trait_select_partition_for_edge_list(value);
  // @@protoc_insertion_point(field_set:grin.PartitionFeature.grin_trait_select_partition_for_edge_list)
}

// bool grin_trait_select_master_neighbor_for_adjacent_list = 12;
inline void PartitionFeature::clear_grin_trait_select_master_neighbor_for_adjacent_list() {
  _impl_.grin_trait_select_master_neighbor_for_adjacent_list_ = false;
}
inline bool PartitionFeature::_internal_grin_trait_select_master_neighbor_for_adjacent_list() const {
  return _impl_.grin_trait_select_master_neighbor_for_adjacent_list_;
}
inline bool PartitionFeature::grin_trait_select_master_neighbor_for_adjacent_list() const {
  // @@protoc_insertion_point(field_get:grin.PartitionFeature.grin_trait_select_master_neighbor_for_adjacent_list)
  return _internal_grin_trait_select_master_neighbor_for_adjacent_list();
}
inline void PartitionFeature::_internal_set_grin_trait_select_master_neighbor_for_adjacent_list(bool value) {
  
  _impl_.grin_trait_select_master_neighbor_for_adjacent_list_ = value;
}
inline void PartitionFeature::set_grin_trait_select_master_neighbor_for_adjacent_list(bool value) {
  _internal_set_grin_trait_select_master_neighbor_for_adjacent_list(value);
  // @@protoc_insertion_point(field_set:grin.PartitionFeature.grin_trait_select_master_neighbor_for_adjacent_list)
}

// bool grin_trait_select_neighbor_partition_for_adjacent_list = 13;
inline void PartitionFeature::clear_grin_trait_select_neighbor_partition_for_adjacent_list() {
  _impl_.grin_trait_select_neighbor_partition_for_adjacent_list_ = false;
}
inline bool PartitionFeature::_internal_grin_trait_select_neighbor_partition_for_adjacent_list() const {
  return _impl_.grin_trait_select_neighbor_partition_for_adjacent_list_;
}
inline bool PartitionFeature::grin_trait_select_neighbor_partition_for_adjacent_list() const {
  // @@protoc_insertion_point(field_get:grin.PartitionFeature.grin_trait_select_neighbor_partition_for_adjacent_list)
  return _internal_grin_trait_select_neighbor_partition_for_adjacent_list();
}
inline void PartitionFeature::_internal_set_grin_trait_select_neighbor_partition_for_adjacent_list(bool value) {
  
  _impl_.grin_trait_select_neighbor_partition_for_adjacent_list_ = value;
}
inline void PartitionFeature::set_grin_trait_select_neighbor_partition_for_adjacent_list(bool value) {
  _internal_set_grin_trait_select_neighbor_partition_for_adjacent_list(value);
  // @@protoc_insertion_point(field_set:grin.PartitionFeature.grin_trait_select_neighbor_partition_for_adjacent_list)
}

// -------------------------------------------------------------------

// VertexPropertyFeature

// bool grin_with_vertex_property = 1;
inline void VertexPropertyFeature::clear_grin_with_vertex_property() {
  _impl_.grin_with_vertex_property_ = false;
}
inline bool VertexPropertyFeature::_internal_grin_with_vertex_property() const {
  return _impl_.grin_with_vertex_property_;
}
inline bool VertexPropertyFeature::grin_with_vertex_property() const {
  // @@protoc_insertion_point(field_get:grin.VertexPropertyFeature.grin_with_vertex_property)
  return _internal_grin_with_vertex_property();
}
inline void VertexPropertyFeature::_internal_set_grin_with_vertex_property(bool value) {
  
  _impl_.grin_with_vertex_property_ = value;
}
inline void VertexPropertyFeature::set_grin_with_vertex_property(bool value) {
  _internal_set_grin_with_vertex_property(value);
  // @@protoc_insertion_point(field_set:grin.VertexPropertyFeature.grin_with_vertex_property)
}

// bool grin_with_vertex_property_name = 2;
inline void VertexPropertyFeature::clear_grin_with_vertex_property_name() {
  _impl_.grin_with_vertex_property_name_ = false;
}
inline bool VertexPropertyFeature::_internal_grin_with_vertex_property_name() const {
  return _impl_.grin_with_vertex_property_name_;
}
inline bool VertexPropertyFeature::grin_with_vertex_property_name() const {
  // @@protoc_insertion_point(field_get:grin.VertexPropertyFeature.grin_with_vertex_property_name)
  return _internal_grin_with_vertex_property_name();
}
inline void VertexPropertyFeature::_internal_set_grin_with_vertex_property_name(bool value) {
  
  _impl_.grin_with_vertex_property_name_ = value;
}
inline void VertexPropertyFeature::set_grin_with_vertex_property_name(bool value) {
  _internal_set_grin_with_vertex_property_name(value);
  // @@protoc_insertion_point(field_set:grin.VertexPropertyFeature.grin_with_vertex_property_name)
}

// bool grin_with_vertex_type_name = 3;
inline void VertexPropertyFeature::clear_grin_with_vertex_type_name() {
  _impl_.grin_with_vertex_type_name_ = false;
}
inline bool VertexPropertyFeature::_internal_grin_with_vertex_type_name() const {
  return _impl_.grin_with_vertex_type_name_;
}
inline bool VertexPropertyFeature::grin_with_vertex_type_name() const {
  // @@protoc_insertion_point(field_get:grin.VertexPropertyFeature.grin_with_vertex_type_name)
  return _internal_grin_with_vertex_type_name();
}
inline void VertexPropertyFeature::_internal_set_grin_with_vertex_type_name(bool value) {
  
  _impl_.grin_with_vertex_type_name_ = value;
}
inline void VertexPropertyFeature::set_grin_with_vertex_type_name(bool value) {
  _internal_set_grin_with_vertex_type_name(value);
  // @@protoc_insertion_point(field_set:grin.VertexPropertyFeature.grin_with_vertex_type_name)
}

// bool grin_enable_vertex_property_table = 4;
inline void VertexPropertyFeature::clear_grin_enable_vertex_property_table() {
  _impl_.grin_enable_vertex_property_table_ = false;
}
inline bool VertexPropertyFeature::_internal_grin_enable_vertex_property_table() const {
  return _impl_.grin_enable_vertex_property_table_;
}
inline bool VertexPropertyFeature::grin_enable_vertex_property_table() const {
  // @@protoc_insertion_point(field_get:grin.VertexPropertyFeature.grin_enable_vertex_property_table)
  return _internal_grin_enable_vertex_property_table();
}
inline void VertexPropertyFeature::_internal_set_grin_enable_vertex_property_table(bool value) {
  
  _impl_.grin_enable_vertex_property_table_ = value;
}
inline void VertexPropertyFeature::set_grin_enable_vertex_property_table(bool value) {
  _internal_set_grin_enable_vertex_property_table(value);
  // @@protoc_insertion_point(field_set:grin.VertexPropertyFeature.grin_enable_vertex_property_table)
}

// bool grin_enable_vertex_primary_keys = 5;
inline void VertexPropertyFeature::clear_grin_enable_vertex_primary_keys() {
  _impl_.grin_enable_vertex_primary_keys_ = false;
}
inline bool VertexPropertyFeature::_internal_grin_enable_vertex_primary_keys() const {
  return _impl_.grin_enable_vertex_primary_keys_;
}
inline bool VertexPropertyFeature::grin_enable_vertex_primary_keys() const {
  // @@protoc_insertion_point(field_get:grin.VertexPropertyFeature.grin_enable_vertex_primary_keys)
  return _internal_grin_enable_vertex_primary_keys();
}
inline void VertexPropertyFeature::_internal_set_grin_enable_vertex_primary_keys(bool value) {
  
  _impl_.grin_enable_vertex_primary_keys_ = value;
}
inline void VertexPropertyFeature::set_grin_enable_vertex_primary_keys(bool value) {
  _internal_set_grin_enable_vertex_primary_keys(value);
  // @@protoc_insertion_point(field_set:grin.VertexPropertyFeature.grin_enable_vertex_primary_keys)
}

// bool grin_trait_natural_id_for_vertex_type = 6;
inline void VertexPropertyFeature::clear_grin_trait_natural_id_for_vertex_type() {
  _impl_.grin_trait_natural_id_for_vertex_type_ = false;
}
inline bool VertexPropertyFeature::_internal_grin_trait_natural_id_for_vertex_type() const {
  return _impl_.grin_trait_natural_id_for_vertex_type_;
}
inline bool VertexPropertyFeature::grin_trait_natural_id_for_vertex_type() const {
  // @@protoc_insertion_point(field_get:grin.VertexPropertyFeature.grin_trait_natural_id_for_vertex_type)
  return _internal_grin_trait_natural_id_for_vertex_type();
}
inline void VertexPropertyFeature::_internal_set_grin_trait_natural_id_for_vertex_type(bool value) {
  
  _impl_.grin_trait_natural_id_for_vertex_type_ = value;
}
inline void VertexPropertyFeature::set_grin_trait_natural_id_for_vertex_type(bool value) {
  _internal_set_grin_trait_natural_id_for_vertex_type(value);
  // @@protoc_insertion_point(field_set:grin.VertexPropertyFeature.grin_trait_natural_id_for_vertex_type)
}

// bool grin_trait_natural_id_for_vertex_property = 7;
inline void VertexPropertyFeature::clear_grin_trait_natural_id_for_vertex_property() {
  _impl_.grin_trait_natural_id_for_vertex_property_ = false;
}
inline bool VertexPropertyFeature::_internal_grin_trait_natural_id_for_vertex_property() const {
  return _impl_.grin_trait_natural_id_for_vertex_property_;
}
inline bool VertexPropertyFeature::grin_trait_natural_id_for_vertex_property() const {
  // @@protoc_insertion_point(field_get:grin.VertexPropertyFeature.grin_trait_natural_id_for_vertex_property)
  return _internal_grin_trait_natural_id_for_vertex_property();
}
inline void VertexPropertyFeature::_internal_set_grin_trait_natural_id_for_vertex_property(bool value) {
  
  _impl_.grin_trait_natural_id_for_vertex_property_ = value;
}
inline void VertexPropertyFeature::set_grin_trait_natural_id_for_vertex_property(bool value) {
  _internal_set_grin_trait_natural_id_for_vertex_property(value);
  // @@protoc_insertion_point(field_set:grin.VertexPropertyFeature.grin_trait_natural_id_for_vertex_property)
}

// bool grin_assume_by_type_vertex_original_id = 8;
inline void VertexPropertyFeature::clear_grin_assume_by_type_vertex_original_id() {
  _impl_.grin_assume_by_type_vertex_original_id_ = false;
}
inline bool VertexPropertyFeature::_internal_grin_assume_by_type_vertex_original_id() const {
  return _impl_.grin_assume_by_type_vertex_original_id_;
}
inline bool VertexPropertyFeature::grin_assume_by_type_vertex_original_id() const {
  // @@protoc_insertion_point(field_get:grin.VertexPropertyFeature.grin_assume_by_type_vertex_original_id)
  return _internal_grin_assume_by_type_vertex_original_id();
}
inline void VertexPropertyFeature::_internal_set_grin_assume_by_type_vertex_original_id(bool value) {
  
  _impl_.grin_assume_by_type_vertex_original_id_ = value;
}
inline void VertexPropertyFeature::set_grin_assume_by_type_vertex_original_id(bool value) {
  _internal_set_grin_assume_by_type_vertex_original_id(value);
  // @@protoc_insertion_point(field_set:grin.VertexPropertyFeature.grin_assume_by_type_vertex_original_id)
}

// -------------------------------------------------------------------

// EdgePropertyFeature

// bool grin_with_edge_property = 1;
inline void EdgePropertyFeature::clear_grin_with_edge_property() {
  _impl_.grin_with_edge_property_ = false;
}
inline bool EdgePropertyFeature::_internal_grin_with_edge_property() const {
  return _impl_.grin_with_edge_property_;
}
inline bool EdgePropertyFeature::grin_with_edge_property() const {
  // @@protoc_insertion_point(field_get:grin.EdgePropertyFeature.grin_with_edge_property)
  return _internal_grin_with_edge_property();
}
inline void EdgePropertyFeature::_internal_set_grin_with_edge_property(bool value) {
  
  _impl_.grin_with_edge_property_ = value;
}
inline void EdgePropertyFeature::set_grin_with_edge_property(bool value) {
  _internal_set_grin_with_edge_property(value);
  // @@protoc_insertion_point(field_set:grin.EdgePropertyFeature.grin_with_edge_property)
}

// bool grin_with_edge_property_name = 2;
inline void EdgePropertyFeature::clear_grin_with_edge_property_name() {
  _impl_.grin_with_edge_property_name_ = false;
}
inline bool EdgePropertyFeature::_internal_grin_with_edge_property_name() const {
  return _impl_.grin_with_edge_property_name_;
}
inline bool EdgePropertyFeature::grin_with_edge_property_name() const {
  // @@protoc_insertion_point(field_get:grin.EdgePropertyFeature.grin_with_edge_property_name)
  return _internal_grin_with_edge_property_name();
}
inline void EdgePropertyFeature::_internal_set_grin_with_edge_property_name(bool value) {
  
  _impl_.grin_with_edge_property_name_ = value;
}
inline void EdgePropertyFeature::set_grin_with_edge_property_name(bool value) {
  _internal_set_grin_with_edge_property_name(value);
  // @@protoc_insertion_point(field_set:grin.EdgePropertyFeature.grin_with_edge_property_name)
}

// bool grin_with_edge_type_name = 3;
inline void EdgePropertyFeature::clear_grin_with_edge_type_name() {
  _impl_.grin_with_edge_type_name_ = false;
}
inline bool EdgePropertyFeature::_internal_grin_with_edge_type_name() const {
  return _impl_.grin_with_edge_type_name_;
}
inline bool EdgePropertyFeature::grin_with_edge_type_name() const {
  // @@protoc_insertion_point(field_get:grin.EdgePropertyFeature.grin_with_edge_type_name)
  return _internal_grin_with_edge_type_name();
}
inline void EdgePropertyFeature::_internal_set_grin_with_edge_type_name(bool value) {
  
  _impl_.grin_with_edge_type_name_ = value;
}
inline void EdgePropertyFeature::set_grin_with_edge_type_name(bool value) {
  _internal_set_grin_with_edge_type_name(value);
  // @@protoc_insertion_point(field_set:grin.EdgePropertyFeature.grin_with_edge_type_name)
}

// bool grin_enable_edge_property_table = 4;
inline void EdgePropertyFeature::clear_grin_enable_edge_property_table() {
  _impl_.grin_enable_edge_property_table_ = false;
}
inline bool EdgePropertyFeature::_internal_grin_enable_edge_property_table() const {
  return _impl_.grin_enable_edge_property_table_;
}
inline bool EdgePropertyFeature::grin_enable_edge_property_table() const {
  // @@protoc_insertion_point(field_get:grin.EdgePropertyFeature.grin_enable_edge_property_table)
  return _internal_grin_enable_edge_property_table();
}
inline void EdgePropertyFeature::_internal_set_grin_enable_edge_property_table(bool value) {
  
  _impl_.grin_enable_edge_property_table_ = value;
}
inline void EdgePropertyFeature::set_grin_enable_edge_property_table(bool value) {
  _internal_set_grin_enable_edge_property_table(value);
  // @@protoc_insertion_point(field_set:grin.EdgePropertyFeature.grin_enable_edge_property_table)
}

// bool grin_enable_edge_primary_keys = 5;
inline void EdgePropertyFeature::clear_grin_enable_edge_primary_keys() {
  _impl_.grin_enable_edge_primary_keys_ = false;
}
inline bool EdgePropertyFeature::_internal_grin_enable_edge_primary_keys() const {
  return _impl_.grin_enable_edge_primary_keys_;
}
inline bool EdgePropertyFeature::grin_enable_edge_primary_keys() const {
  // @@protoc_insertion_point(field_get:grin.EdgePropertyFeature.grin_enable_edge_primary_keys)
  return _internal_grin_enable_edge_primary_keys();
}
inline void EdgePropertyFeature::_internal_set_grin_enable_edge_primary_keys(bool value) {
  
  _impl_.grin_enable_edge_primary_keys_ = value;
}
inline void EdgePropertyFeature::set_grin_enable_edge_primary_keys(bool value) {
  _internal_set_grin_enable_edge_primary_keys(value);
  // @@protoc_insertion_point(field_set:grin.EdgePropertyFeature.grin_enable_edge_primary_keys)
}

// bool grin_trait_natural_id_for_edge_type = 6;
inline void EdgePropertyFeature::clear_grin_trait_natural_id_for_edge_type() {
  _impl_.grin_trait_natural_id_for_edge_type_ = false;
}
inline bool EdgePropertyFeature::_internal_grin_trait_natural_id_for_edge_type() const {
  return _impl_.grin_trait_natural_id_for_edge_type_;
}
inline bool EdgePropertyFeature::grin_trait_natural_id_for_edge_type() const {
  // @@protoc_insertion_point(field_get:grin.EdgePropertyFeature.grin_trait_natural_id_for_edge_type)
  return _internal_grin_trait_natural_id_for_edge_type();
}
inline void EdgePropertyFeature::_internal_set_grin_trait_natural_id_for_edge_type(bool value) {
  
  _impl_.grin_trait_natural_id_for_edge_type_ = value;
}
inline void EdgePropertyFeature::set_grin_trait_natural_id_for_edge_type(bool value) {
  _internal_set_grin_trait_natural_id_for_edge_type(value);
  // @@protoc_insertion_point(field_set:grin.EdgePropertyFeature.grin_trait_natural_id_for_edge_type)
}

// bool grin_trait_natural_id_for_edge_property = 7;
inline void EdgePropertyFeature::clear_grin_trait_natural_id_for_edge_property() {
  _impl_.grin_trait_natural_id_for_edge_property_ = false;
}
inline bool EdgePropertyFeature::_internal_grin_trait_natural_id_for_edge_property() const {
  return _impl_.grin_trait_natural_id_for_edge_property_;
}
inline bool EdgePropertyFeature::grin_trait_natural_id_for_edge_property() const {
  // @@protoc_insertion_point(field_get:grin.EdgePropertyFeature.grin_trait_natural_id_for_edge_property)
  return _internal_grin_trait_natural_id_for_edge_property();
}
inline void EdgePropertyFeature::_internal_set_grin_trait_natural_id_for_edge_property(bool value) {
  
  _impl_.grin_trait_natural_id_for_edge_property_ = value;
}
inline void EdgePropertyFeature::set_grin_trait_natural_id_for_edge_property(bool value) {
  _internal_set_grin_trait_natural_id_for_edge_property(value);
  // @@protoc_insertion_point(field_set:grin.EdgePropertyFeature.grin_trait_natural_id_for_edge_property)
}

// -------------------------------------------------------------------

// PropertyFeature

// bool grin_enable_row = 1;
inline void PropertyFeature::clear_grin_enable_row() {
  _impl_.grin_enable_row_ = false;
}
inline bool PropertyFeature::_internal_grin_enable_row() const {
  return _impl_.grin_enable_row_;
}
inline bool PropertyFeature::grin_enable_row() const {
  // @@protoc_insertion_point(field_get:grin.PropertyFeature.grin_enable_row)
  return _internal_grin_enable_row();
}
inline void PropertyFeature::_internal_set_grin_enable_row(bool value) {
  
  _impl_.grin_enable_row_ = value;
}
inline void PropertyFeature::set_grin_enable_row(bool value) {
  _internal_set_grin_enable_row(value);
  // @@protoc_insertion_point(field_set:grin.PropertyFeature.grin_enable_row)
}

// .grin.VertexPropertyFeature vertex_property_feature = 2;
inline bool PropertyFeature::_internal_has_vertex_property_feature() const {
  return this != internal_default_instance() && _impl_.vertex_property_feature_ != nullptr;
}
inline bool PropertyFeature::has_vertex_property_feature() const {
  return _internal_has_vertex_property_feature();
}
inline void PropertyFeature::clear_vertex_property_feature() {
  if (GetArenaForAllocation() == nullptr && _impl_.vertex_property_feature_ != nullptr) {
    delete _impl_.vertex_property_feature_;
  }
  _impl_.vertex_property_feature_ = nullptr;
}
inline const ::grin::VertexPropertyFeature& PropertyFeature::_internal_vertex_property_feature() const {
  const ::grin::VertexPropertyFeature* p = _impl_.vertex_property_feature_;
  return p != nullptr ? *p : reinterpret_cast<const ::grin::VertexPropertyFeature&>(
      ::grin::_VertexPropertyFeature_default_instance_);
}
inline const ::grin::VertexPropertyFeature& PropertyFeature::vertex_property_feature() const {
  // @@protoc_insertion_point(field_get:grin.PropertyFeature.vertex_property_feature)
  return _internal_vertex_property_feature();
}
inline void PropertyFeature::unsafe_arena_set_allocated_vertex_property_feature(
    ::grin::VertexPropertyFeature* vertex_property_feature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vertex_property_feature_);
  }
  _impl_.vertex_property_feature_ = vertex_property_feature;
  if (vertex_property_feature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grin.PropertyFeature.vertex_property_feature)
}
inline ::grin::VertexPropertyFeature* PropertyFeature::release_vertex_property_feature() {
  
  ::grin::VertexPropertyFeature* temp = _impl_.vertex_property_feature_;
  _impl_.vertex_property_feature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grin::VertexPropertyFeature* PropertyFeature::unsafe_arena_release_vertex_property_feature() {
  // @@protoc_insertion_point(field_release:grin.PropertyFeature.vertex_property_feature)
  
  ::grin::VertexPropertyFeature* temp = _impl_.vertex_property_feature_;
  _impl_.vertex_property_feature_ = nullptr;
  return temp;
}
inline ::grin::VertexPropertyFeature* PropertyFeature::_internal_mutable_vertex_property_feature() {
  
  if (_impl_.vertex_property_feature_ == nullptr) {
    auto* p = CreateMaybeMessage<::grin::VertexPropertyFeature>(GetArenaForAllocation());
    _impl_.vertex_property_feature_ = p;
  }
  return _impl_.vertex_property_feature_;
}
inline ::grin::VertexPropertyFeature* PropertyFeature::mutable_vertex_property_feature() {
  ::grin::VertexPropertyFeature* _msg = _internal_mutable_vertex_property_feature();
  // @@protoc_insertion_point(field_mutable:grin.PropertyFeature.vertex_property_feature)
  return _msg;
}
inline void PropertyFeature::set_allocated_vertex_property_feature(::grin::VertexPropertyFeature* vertex_property_feature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vertex_property_feature_;
  }
  if (vertex_property_feature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vertex_property_feature);
    if (message_arena != submessage_arena) {
      vertex_property_feature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vertex_property_feature, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vertex_property_feature_ = vertex_property_feature;
  // @@protoc_insertion_point(field_set_allocated:grin.PropertyFeature.vertex_property_feature)
}

// .grin.EdgePropertyFeature edge_property_feature = 3;
inline bool PropertyFeature::_internal_has_edge_property_feature() const {
  return this != internal_default_instance() && _impl_.edge_property_feature_ != nullptr;
}
inline bool PropertyFeature::has_edge_property_feature() const {
  return _internal_has_edge_property_feature();
}
inline void PropertyFeature::clear_edge_property_feature() {
  if (GetArenaForAllocation() == nullptr && _impl_.edge_property_feature_ != nullptr) {
    delete _impl_.edge_property_feature_;
  }
  _impl_.edge_property_feature_ = nullptr;
}
inline const ::grin::EdgePropertyFeature& PropertyFeature::_internal_edge_property_feature() const {
  const ::grin::EdgePropertyFeature* p = _impl_.edge_property_feature_;
  return p != nullptr ? *p : reinterpret_cast<const ::grin::EdgePropertyFeature&>(
      ::grin::_EdgePropertyFeature_default_instance_);
}
inline const ::grin::EdgePropertyFeature& PropertyFeature::edge_property_feature() const {
  // @@protoc_insertion_point(field_get:grin.PropertyFeature.edge_property_feature)
  return _internal_edge_property_feature();
}
inline void PropertyFeature::unsafe_arena_set_allocated_edge_property_feature(
    ::grin::EdgePropertyFeature* edge_property_feature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.edge_property_feature_);
  }
  _impl_.edge_property_feature_ = edge_property_feature;
  if (edge_property_feature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grin.PropertyFeature.edge_property_feature)
}
inline ::grin::EdgePropertyFeature* PropertyFeature::release_edge_property_feature() {
  
  ::grin::EdgePropertyFeature* temp = _impl_.edge_property_feature_;
  _impl_.edge_property_feature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grin::EdgePropertyFeature* PropertyFeature::unsafe_arena_release_edge_property_feature() {
  // @@protoc_insertion_point(field_release:grin.PropertyFeature.edge_property_feature)
  
  ::grin::EdgePropertyFeature* temp = _impl_.edge_property_feature_;
  _impl_.edge_property_feature_ = nullptr;
  return temp;
}
inline ::grin::EdgePropertyFeature* PropertyFeature::_internal_mutable_edge_property_feature() {
  
  if (_impl_.edge_property_feature_ == nullptr) {
    auto* p = CreateMaybeMessage<::grin::EdgePropertyFeature>(GetArenaForAllocation());
    _impl_.edge_property_feature_ = p;
  }
  return _impl_.edge_property_feature_;
}
inline ::grin::EdgePropertyFeature* PropertyFeature::mutable_edge_property_feature() {
  ::grin::EdgePropertyFeature* _msg = _internal_mutable_edge_property_feature();
  // @@protoc_insertion_point(field_mutable:grin.PropertyFeature.edge_property_feature)
  return _msg;
}
inline void PropertyFeature::set_allocated_edge_property_feature(::grin::EdgePropertyFeature* edge_property_feature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.edge_property_feature_;
  }
  if (edge_property_feature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(edge_property_feature);
    if (message_arena != submessage_arena) {
      edge_property_feature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge_property_feature, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.edge_property_feature_ = edge_property_feature;
  // @@protoc_insertion_point(field_set_allocated:grin.PropertyFeature.edge_property_feature)
}

// .grin.PropertyDataPartitionStrategy vertex_property = 4;
inline void PropertyFeature::clear_vertex_property() {
  _impl_.vertex_property_ = 0;
}
inline ::grin::PropertyDataPartitionStrategy PropertyFeature::_internal_vertex_property() const {
  return static_cast< ::grin::PropertyDataPartitionStrategy >(_impl_.vertex_property_);
}
inline ::grin::PropertyDataPartitionStrategy PropertyFeature::vertex_property() const {
  // @@protoc_insertion_point(field_get:grin.PropertyFeature.vertex_property)
  return _internal_vertex_property();
}
inline void PropertyFeature::_internal_set_vertex_property(::grin::PropertyDataPartitionStrategy value) {
  
  _impl_.vertex_property_ = value;
}
inline void PropertyFeature::set_vertex_property(::grin::PropertyDataPartitionStrategy value) {
  _internal_set_vertex_property(value);
  // @@protoc_insertion_point(field_set:grin.PropertyFeature.vertex_property)
}

// .grin.PropertyDataPartitionStrategy edge_property = 5;
inline void PropertyFeature::clear_edge_property() {
  _impl_.edge_property_ = 0;
}
inline ::grin::PropertyDataPartitionStrategy PropertyFeature::_internal_edge_property() const {
  return static_cast< ::grin::PropertyDataPartitionStrategy >(_impl_.edge_property_);
}
inline ::grin::PropertyDataPartitionStrategy PropertyFeature::edge_property() const {
  // @@protoc_insertion_point(field_get:grin.PropertyFeature.edge_property)
  return _internal_edge_property();
}
inline void PropertyFeature::_internal_set_edge_property(::grin::PropertyDataPartitionStrategy value) {
  
  _impl_.edge_property_ = value;
}
inline void PropertyFeature::set_edge_property(::grin::PropertyDataPartitionStrategy value) {
  _internal_set_edge_property(value);
  // @@protoc_insertion_point(field_set:grin.PropertyFeature.edge_property)
}

// bool grin_assume_column_store_for_vertex_property = 6;
inline void PropertyFeature::clear_grin_assume_column_store_for_vertex_property() {
  _impl_.grin_assume_column_store_for_vertex_property_ = false;
}
inline bool PropertyFeature::_internal_grin_assume_column_store_for_vertex_property() const {
  return _impl_.grin_assume_column_store_for_vertex_property_;
}
inline bool PropertyFeature::grin_assume_column_store_for_vertex_property() const {
  // @@protoc_insertion_point(field_get:grin.PropertyFeature.grin_assume_column_store_for_vertex_property)
  return _internal_grin_assume_column_store_for_vertex_property();
}
inline void PropertyFeature::_internal_set_grin_assume_column_store_for_vertex_property(bool value) {
  
  _impl_.grin_assume_column_store_for_vertex_property_ = value;
}
inline void PropertyFeature::set_grin_assume_column_store_for_vertex_property(bool value) {
  _internal_set_grin_assume_column_store_for_vertex_property(value);
  // @@protoc_insertion_point(field_set:grin.PropertyFeature.grin_assume_column_store_for_vertex_property)
}

// bool grin_assume_column_store_for_edge_property = 7;
inline void PropertyFeature::clear_grin_assume_column_store_for_edge_property() {
  _impl_.grin_assume_column_store_for_edge_property_ = false;
}
inline bool PropertyFeature::_internal_grin_assume_column_store_for_edge_property() const {
  return _impl_.grin_assume_column_store_for_edge_property_;
}
inline bool PropertyFeature::grin_assume_column_store_for_edge_property() const {
  // @@protoc_insertion_point(field_get:grin.PropertyFeature.grin_assume_column_store_for_edge_property)
  return _internal_grin_assume_column_store_for_edge_property();
}
inline void PropertyFeature::_internal_set_grin_assume_column_store_for_edge_property(bool value) {
  
  _impl_.grin_assume_column_store_for_edge_property_ = value;
}
inline void PropertyFeature::set_grin_assume_column_store_for_edge_property(bool value) {
  _internal_set_grin_assume_column_store_for_edge_property(value);
  // @@protoc_insertion_point(field_set:grin.PropertyFeature.grin_assume_column_store_for_edge_property)
}

// bool grin_trait_select_type_for_vertex_list = 8;
inline void PropertyFeature::clear_grin_trait_select_type_for_vertex_list() {
  _impl_.grin_trait_select_type_for_vertex_list_ = false;
}
inline bool PropertyFeature::_internal_grin_trait_select_type_for_vertex_list() const {
  return _impl_.grin_trait_select_type_for_vertex_list_;
}
inline bool PropertyFeature::grin_trait_select_type_for_vertex_list() const {
  // @@protoc_insertion_point(field_get:grin.PropertyFeature.grin_trait_select_type_for_vertex_list)
  return _internal_grin_trait_select_type_for_vertex_list();
}
inline void PropertyFeature::_internal_set_grin_trait_select_type_for_vertex_list(bool value) {
  
  _impl_.grin_trait_select_type_for_vertex_list_ = value;
}
inline void PropertyFeature::set_grin_trait_select_type_for_vertex_list(bool value) {
  _internal_set_grin_trait_select_type_for_vertex_list(value);
  // @@protoc_insertion_point(field_set:grin.PropertyFeature.grin_trait_select_type_for_vertex_list)
}

// bool grin_trait_select_type_for_edge_list = 9;
inline void PropertyFeature::clear_grin_trait_select_type_for_edge_list() {
  _impl_.grin_trait_select_type_for_edge_list_ = false;
}
inline bool PropertyFeature::_internal_grin_trait_select_type_for_edge_list() const {
  return _impl_.grin_trait_select_type_for_edge_list_;
}
inline bool PropertyFeature::grin_trait_select_type_for_edge_list() const {
  // @@protoc_insertion_point(field_get:grin.PropertyFeature.grin_trait_select_type_for_edge_list)
  return _internal_grin_trait_select_type_for_edge_list();
}
inline void PropertyFeature::_internal_set_grin_trait_select_type_for_edge_list(bool value) {
  
  _impl_.grin_trait_select_type_for_edge_list_ = value;
}
inline void PropertyFeature::set_grin_trait_select_type_for_edge_list(bool value) {
  _internal_set_grin_trait_select_type_for_edge_list(value);
  // @@protoc_insertion_point(field_set:grin.PropertyFeature.grin_trait_select_type_for_edge_list)
}

// bool grin_trait_select_neighbor_type_for_adjacent_list = 10;
inline void PropertyFeature::clear_grin_trait_select_neighbor_type_for_adjacent_list() {
  _impl_.grin_trait_select_neighbor_type_for_adjacent_list_ = false;
}
inline bool PropertyFeature::_internal_grin_trait_select_neighbor_type_for_adjacent_list() const {
  return _impl_.grin_trait_select_neighbor_type_for_adjacent_list_;
}
inline bool PropertyFeature::grin_trait_select_neighbor_type_for_adjacent_list() const {
  // @@protoc_insertion_point(field_get:grin.PropertyFeature.grin_trait_select_neighbor_type_for_adjacent_list)
  return _internal_grin_trait_select_neighbor_type_for_adjacent_list();
}
inline void PropertyFeature::_internal_set_grin_trait_select_neighbor_type_for_adjacent_list(bool value) {
  
  _impl_.grin_trait_select_neighbor_type_for_adjacent_list_ = value;
}
inline void PropertyFeature::set_grin_trait_select_neighbor_type_for_adjacent_list(bool value) {
  _internal_set_grin_trait_select_neighbor_type_for_adjacent_list(value);
  // @@protoc_insertion_point(field_set:grin.PropertyFeature.grin_trait_select_neighbor_type_for_adjacent_list)
}

// bool grin_trait_select_edge_type_for_adjacent_list = 11;
inline void PropertyFeature::clear_grin_trait_select_edge_type_for_adjacent_list() {
  _impl_.grin_trait_select_edge_type_for_adjacent_list_ = false;
}
inline bool PropertyFeature::_internal_grin_trait_select_edge_type_for_adjacent_list() const {
  return _impl_.grin_trait_select_edge_type_for_adjacent_list_;
}
inline bool PropertyFeature::grin_trait_select_edge_type_for_adjacent_list() const {
  // @@protoc_insertion_point(field_get:grin.PropertyFeature.grin_trait_select_edge_type_for_adjacent_list)
  return _internal_grin_trait_select_edge_type_for_adjacent_list();
}
inline void PropertyFeature::_internal_set_grin_trait_select_edge_type_for_adjacent_list(bool value) {
  
  _impl_.grin_trait_select_edge_type_for_adjacent_list_ = value;
}
inline void PropertyFeature::set_grin_trait_select_edge_type_for_adjacent_list(bool value) {
  _internal_set_grin_trait_select_edge_type_for_adjacent_list(value);
  // @@protoc_insertion_point(field_set:grin.PropertyFeature.grin_trait_select_edge_type_for_adjacent_list)
}

// bool grin_trait_specific_vev_relation = 12;
inline void PropertyFeature::clear_grin_trait_specific_vev_relation() {
  _impl_.grin_trait_specific_vev_relation_ = false;
}
inline bool PropertyFeature::_internal_grin_trait_specific_vev_relation() const {
  return _impl_.grin_trait_specific_vev_relation_;
}
inline bool PropertyFeature::grin_trait_specific_vev_relation() const {
  // @@protoc_insertion_point(field_get:grin.PropertyFeature.grin_trait_specific_vev_relation)
  return _internal_grin_trait_specific_vev_relation();
}
inline void PropertyFeature::_internal_set_grin_trait_specific_vev_relation(bool value) {
  
  _impl_.grin_trait_specific_vev_relation_ = value;
}
inline void PropertyFeature::set_grin_trait_specific_vev_relation(bool value) {
  _internal_set_grin_trait_specific_vev_relation(value);
  // @@protoc_insertion_point(field_set:grin.PropertyFeature.grin_trait_specific_vev_relation)
}

// -------------------------------------------------------------------

// IndexFeature

// bool grin_with_vertex_label = 1;
inline void IndexFeature::clear_grin_with_vertex_label() {
  _impl_.grin_with_vertex_label_ = false;
}
inline bool IndexFeature::_internal_grin_with_vertex_label() const {
  return _impl_.grin_with_vertex_label_;
}
inline bool IndexFeature::grin_with_vertex_label() const {
  // @@protoc_insertion_point(field_get:grin.IndexFeature.grin_with_vertex_label)
  return _internal_grin_with_vertex_label();
}
inline void IndexFeature::_internal_set_grin_with_vertex_label(bool value) {
  
  _impl_.grin_with_vertex_label_ = value;
}
inline void IndexFeature::set_grin_with_vertex_label(bool value) {
  _internal_set_grin_with_vertex_label(value);
  // @@protoc_insertion_point(field_set:grin.IndexFeature.grin_with_vertex_label)
}

// bool grin_with_edge_label = 2;
inline void IndexFeature::clear_grin_with_edge_label() {
  _impl_.grin_with_edge_label_ = false;
}
inline bool IndexFeature::_internal_grin_with_edge_label() const {
  return _impl_.grin_with_edge_label_;
}
inline bool IndexFeature::grin_with_edge_label() const {
  // @@protoc_insertion_point(field_get:grin.IndexFeature.grin_with_edge_label)
  return _internal_grin_with_edge_label();
}
inline void IndexFeature::_internal_set_grin_with_edge_label(bool value) {
  
  _impl_.grin_with_edge_label_ = value;
}
inline void IndexFeature::set_grin_with_edge_label(bool value) {
  _internal_set_grin_with_edge_label(value);
  // @@protoc_insertion_point(field_set:grin.IndexFeature.grin_with_edge_label)
}

// bool grin_assume_all_vertex_list_sorted = 3;
inline void IndexFeature::clear_grin_assume_all_vertex_list_sorted() {
  _impl_.grin_assume_all_vertex_list_sorted_ = false;
}
inline bool IndexFeature::_internal_grin_assume_all_vertex_list_sorted() const {
  return _impl_.grin_assume_all_vertex_list_sorted_;
}
inline bool IndexFeature::grin_assume_all_vertex_list_sorted() const {
  // @@protoc_insertion_point(field_get:grin.IndexFeature.grin_assume_all_vertex_list_sorted)
  return _internal_grin_assume_all_vertex_list_sorted();
}
inline void IndexFeature::_internal_set_grin_assume_all_vertex_list_sorted(bool value) {
  
  _impl_.grin_assume_all_vertex_list_sorted_ = value;
}
inline void IndexFeature::set_grin_assume_all_vertex_list_sorted(bool value) {
  _internal_set_grin_assume_all_vertex_list_sorted(value);
  // @@protoc_insertion_point(field_set:grin.IndexFeature.grin_assume_all_vertex_list_sorted)
}

// -------------------------------------------------------------------

// PredicateFeature

// -------------------------------------------------------------------

// StorageFeature

// .grin.TopologyFeature topology_feature = 1;
inline bool StorageFeature::_internal_has_topology_feature() const {
  return specific_feature_case() == kTopologyFeature;
}
inline bool StorageFeature::has_topology_feature() const {
  return _internal_has_topology_feature();
}
inline void StorageFeature::set_has_topology_feature() {
  _impl_._oneof_case_[0] = kTopologyFeature;
}
inline void StorageFeature::clear_topology_feature() {
  if (_internal_has_topology_feature()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.specific_feature_.topology_feature_;
    }
    clear_has_specific_feature();
  }
}
inline ::grin::TopologyFeature* StorageFeature::release_topology_feature() {
  // @@protoc_insertion_point(field_release:grin.StorageFeature.topology_feature)
  if (_internal_has_topology_feature()) {
    clear_has_specific_feature();
    ::grin::TopologyFeature* temp = _impl_.specific_feature_.topology_feature_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.specific_feature_.topology_feature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grin::TopologyFeature& StorageFeature::_internal_topology_feature() const {
  return _internal_has_topology_feature()
      ? *_impl_.specific_feature_.topology_feature_
      : reinterpret_cast< ::grin::TopologyFeature&>(::grin::_TopologyFeature_default_instance_);
}
inline const ::grin::TopologyFeature& StorageFeature::topology_feature() const {
  // @@protoc_insertion_point(field_get:grin.StorageFeature.topology_feature)
  return _internal_topology_feature();
}
inline ::grin::TopologyFeature* StorageFeature::unsafe_arena_release_topology_feature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grin.StorageFeature.topology_feature)
  if (_internal_has_topology_feature()) {
    clear_has_specific_feature();
    ::grin::TopologyFeature* temp = _impl_.specific_feature_.topology_feature_;
    _impl_.specific_feature_.topology_feature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StorageFeature::unsafe_arena_set_allocated_topology_feature(::grin::TopologyFeature* topology_feature) {
  clear_specific_feature();
  if (topology_feature) {
    set_has_topology_feature();
    _impl_.specific_feature_.topology_feature_ = topology_feature;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grin.StorageFeature.topology_feature)
}
inline ::grin::TopologyFeature* StorageFeature::_internal_mutable_topology_feature() {
  if (!_internal_has_topology_feature()) {
    clear_specific_feature();
    set_has_topology_feature();
    _impl_.specific_feature_.topology_feature_ = CreateMaybeMessage< ::grin::TopologyFeature >(GetArenaForAllocation());
  }
  return _impl_.specific_feature_.topology_feature_;
}
inline ::grin::TopologyFeature* StorageFeature::mutable_topology_feature() {
  ::grin::TopologyFeature* _msg = _internal_mutable_topology_feature();
  // @@protoc_insertion_point(field_mutable:grin.StorageFeature.topology_feature)
  return _msg;
}

// .grin.PartitionFeature partition_feature = 2;
inline bool StorageFeature::_internal_has_partition_feature() const {
  return specific_feature_case() == kPartitionFeature;
}
inline bool StorageFeature::has_partition_feature() const {
  return _internal_has_partition_feature();
}
inline void StorageFeature::set_has_partition_feature() {
  _impl_._oneof_case_[0] = kPartitionFeature;
}
inline void StorageFeature::clear_partition_feature() {
  if (_internal_has_partition_feature()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.specific_feature_.partition_feature_;
    }
    clear_has_specific_feature();
  }
}
inline ::grin::PartitionFeature* StorageFeature::release_partition_feature() {
  // @@protoc_insertion_point(field_release:grin.StorageFeature.partition_feature)
  if (_internal_has_partition_feature()) {
    clear_has_specific_feature();
    ::grin::PartitionFeature* temp = _impl_.specific_feature_.partition_feature_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.specific_feature_.partition_feature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grin::PartitionFeature& StorageFeature::_internal_partition_feature() const {
  return _internal_has_partition_feature()
      ? *_impl_.specific_feature_.partition_feature_
      : reinterpret_cast< ::grin::PartitionFeature&>(::grin::_PartitionFeature_default_instance_);
}
inline const ::grin::PartitionFeature& StorageFeature::partition_feature() const {
  // @@protoc_insertion_point(field_get:grin.StorageFeature.partition_feature)
  return _internal_partition_feature();
}
inline ::grin::PartitionFeature* StorageFeature::unsafe_arena_release_partition_feature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grin.StorageFeature.partition_feature)
  if (_internal_has_partition_feature()) {
    clear_has_specific_feature();
    ::grin::PartitionFeature* temp = _impl_.specific_feature_.partition_feature_;
    _impl_.specific_feature_.partition_feature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StorageFeature::unsafe_arena_set_allocated_partition_feature(::grin::PartitionFeature* partition_feature) {
  clear_specific_feature();
  if (partition_feature) {
    set_has_partition_feature();
    _impl_.specific_feature_.partition_feature_ = partition_feature;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grin.StorageFeature.partition_feature)
}
inline ::grin::PartitionFeature* StorageFeature::_internal_mutable_partition_feature() {
  if (!_internal_has_partition_feature()) {
    clear_specific_feature();
    set_has_partition_feature();
    _impl_.specific_feature_.partition_feature_ = CreateMaybeMessage< ::grin::PartitionFeature >(GetArenaForAllocation());
  }
  return _impl_.specific_feature_.partition_feature_;
}
inline ::grin::PartitionFeature* StorageFeature::mutable_partition_feature() {
  ::grin::PartitionFeature* _msg = _internal_mutable_partition_feature();
  // @@protoc_insertion_point(field_mutable:grin.StorageFeature.partition_feature)
  return _msg;
}

// .grin.PropertyFeature property_feature = 3;
inline bool StorageFeature::_internal_has_property_feature() const {
  return specific_feature_case() == kPropertyFeature;
}
inline bool StorageFeature::has_property_feature() const {
  return _internal_has_property_feature();
}
inline void StorageFeature::set_has_property_feature() {
  _impl_._oneof_case_[0] = kPropertyFeature;
}
inline void StorageFeature::clear_property_feature() {
  if (_internal_has_property_feature()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.specific_feature_.property_feature_;
    }
    clear_has_specific_feature();
  }
}
inline ::grin::PropertyFeature* StorageFeature::release_property_feature() {
  // @@protoc_insertion_point(field_release:grin.StorageFeature.property_feature)
  if (_internal_has_property_feature()) {
    clear_has_specific_feature();
    ::grin::PropertyFeature* temp = _impl_.specific_feature_.property_feature_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.specific_feature_.property_feature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grin::PropertyFeature& StorageFeature::_internal_property_feature() const {
  return _internal_has_property_feature()
      ? *_impl_.specific_feature_.property_feature_
      : reinterpret_cast< ::grin::PropertyFeature&>(::grin::_PropertyFeature_default_instance_);
}
inline const ::grin::PropertyFeature& StorageFeature::property_feature() const {
  // @@protoc_insertion_point(field_get:grin.StorageFeature.property_feature)
  return _internal_property_feature();
}
inline ::grin::PropertyFeature* StorageFeature::unsafe_arena_release_property_feature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grin.StorageFeature.property_feature)
  if (_internal_has_property_feature()) {
    clear_has_specific_feature();
    ::grin::PropertyFeature* temp = _impl_.specific_feature_.property_feature_;
    _impl_.specific_feature_.property_feature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StorageFeature::unsafe_arena_set_allocated_property_feature(::grin::PropertyFeature* property_feature) {
  clear_specific_feature();
  if (property_feature) {
    set_has_property_feature();
    _impl_.specific_feature_.property_feature_ = property_feature;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grin.StorageFeature.property_feature)
}
inline ::grin::PropertyFeature* StorageFeature::_internal_mutable_property_feature() {
  if (!_internal_has_property_feature()) {
    clear_specific_feature();
    set_has_property_feature();
    _impl_.specific_feature_.property_feature_ = CreateMaybeMessage< ::grin::PropertyFeature >(GetArenaForAllocation());
  }
  return _impl_.specific_feature_.property_feature_;
}
inline ::grin::PropertyFeature* StorageFeature::mutable_property_feature() {
  ::grin::PropertyFeature* _msg = _internal_mutable_property_feature();
  // @@protoc_insertion_point(field_mutable:grin.StorageFeature.property_feature)
  return _msg;
}

// .grin.IndexFeature index_feature = 4;
inline bool StorageFeature::_internal_has_index_feature() const {
  return specific_feature_case() == kIndexFeature;
}
inline bool StorageFeature::has_index_feature() const {
  return _internal_has_index_feature();
}
inline void StorageFeature::set_has_index_feature() {
  _impl_._oneof_case_[0] = kIndexFeature;
}
inline void StorageFeature::clear_index_feature() {
  if (_internal_has_index_feature()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.specific_feature_.index_feature_;
    }
    clear_has_specific_feature();
  }
}
inline ::grin::IndexFeature* StorageFeature::release_index_feature() {
  // @@protoc_insertion_point(field_release:grin.StorageFeature.index_feature)
  if (_internal_has_index_feature()) {
    clear_has_specific_feature();
    ::grin::IndexFeature* temp = _impl_.specific_feature_.index_feature_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.specific_feature_.index_feature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grin::IndexFeature& StorageFeature::_internal_index_feature() const {
  return _internal_has_index_feature()
      ? *_impl_.specific_feature_.index_feature_
      : reinterpret_cast< ::grin::IndexFeature&>(::grin::_IndexFeature_default_instance_);
}
inline const ::grin::IndexFeature& StorageFeature::index_feature() const {
  // @@protoc_insertion_point(field_get:grin.StorageFeature.index_feature)
  return _internal_index_feature();
}
inline ::grin::IndexFeature* StorageFeature::unsafe_arena_release_index_feature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grin.StorageFeature.index_feature)
  if (_internal_has_index_feature()) {
    clear_has_specific_feature();
    ::grin::IndexFeature* temp = _impl_.specific_feature_.index_feature_;
    _impl_.specific_feature_.index_feature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StorageFeature::unsafe_arena_set_allocated_index_feature(::grin::IndexFeature* index_feature) {
  clear_specific_feature();
  if (index_feature) {
    set_has_index_feature();
    _impl_.specific_feature_.index_feature_ = index_feature;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grin.StorageFeature.index_feature)
}
inline ::grin::IndexFeature* StorageFeature::_internal_mutable_index_feature() {
  if (!_internal_has_index_feature()) {
    clear_specific_feature();
    set_has_index_feature();
    _impl_.specific_feature_.index_feature_ = CreateMaybeMessage< ::grin::IndexFeature >(GetArenaForAllocation());
  }
  return _impl_.specific_feature_.index_feature_;
}
inline ::grin::IndexFeature* StorageFeature::mutable_index_feature() {
  ::grin::IndexFeature* _msg = _internal_mutable_index_feature();
  // @@protoc_insertion_point(field_mutable:grin.StorageFeature.index_feature)
  return _msg;
}

// .grin.PredicateFeature predicate_feature = 5;
inline bool StorageFeature::_internal_has_predicate_feature() const {
  return specific_feature_case() == kPredicateFeature;
}
inline bool StorageFeature::has_predicate_feature() const {
  return _internal_has_predicate_feature();
}
inline void StorageFeature::set_has_predicate_feature() {
  _impl_._oneof_case_[0] = kPredicateFeature;
}
inline void StorageFeature::clear_predicate_feature() {
  if (_internal_has_predicate_feature()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.specific_feature_.predicate_feature_;
    }
    clear_has_specific_feature();
  }
}
inline ::grin::PredicateFeature* StorageFeature::release_predicate_feature() {
  // @@protoc_insertion_point(field_release:grin.StorageFeature.predicate_feature)
  if (_internal_has_predicate_feature()) {
    clear_has_specific_feature();
    ::grin::PredicateFeature* temp = _impl_.specific_feature_.predicate_feature_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.specific_feature_.predicate_feature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grin::PredicateFeature& StorageFeature::_internal_predicate_feature() const {
  return _internal_has_predicate_feature()
      ? *_impl_.specific_feature_.predicate_feature_
      : reinterpret_cast< ::grin::PredicateFeature&>(::grin::_PredicateFeature_default_instance_);
}
inline const ::grin::PredicateFeature& StorageFeature::predicate_feature() const {
  // @@protoc_insertion_point(field_get:grin.StorageFeature.predicate_feature)
  return _internal_predicate_feature();
}
inline ::grin::PredicateFeature* StorageFeature::unsafe_arena_release_predicate_feature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grin.StorageFeature.predicate_feature)
  if (_internal_has_predicate_feature()) {
    clear_has_specific_feature();
    ::grin::PredicateFeature* temp = _impl_.specific_feature_.predicate_feature_;
    _impl_.specific_feature_.predicate_feature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StorageFeature::unsafe_arena_set_allocated_predicate_feature(::grin::PredicateFeature* predicate_feature) {
  clear_specific_feature();
  if (predicate_feature) {
    set_has_predicate_feature();
    _impl_.specific_feature_.predicate_feature_ = predicate_feature;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grin.StorageFeature.predicate_feature)
}
inline ::grin::PredicateFeature* StorageFeature::_internal_mutable_predicate_feature() {
  if (!_internal_has_predicate_feature()) {
    clear_specific_feature();
    set_has_predicate_feature();
    _impl_.specific_feature_.predicate_feature_ = CreateMaybeMessage< ::grin::PredicateFeature >(GetArenaForAllocation());
  }
  return _impl_.specific_feature_.predicate_feature_;
}
inline ::grin::PredicateFeature* StorageFeature::mutable_predicate_feature() {
  ::grin::PredicateFeature* _msg = _internal_mutable_predicate_feature();
  // @@protoc_insertion_point(field_mutable:grin.StorageFeature.predicate_feature)
  return _msg;
}

inline bool StorageFeature::has_specific_feature() const {
  return specific_feature_case() != SPECIFIC_FEATURE_NOT_SET;
}
inline void StorageFeature::clear_has_specific_feature() {
  _impl_._oneof_case_[0] = SPECIFIC_FEATURE_NOT_SET;
}
inline StorageFeature::SpecificFeatureCase StorageFeature::specific_feature_case() const {
  return StorageFeature::SpecificFeatureCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Statistics

// int32 vertex_count = 1;
inline void Statistics::clear_vertex_count() {
  _impl_.vertex_count_ = 0;
}
inline int32_t Statistics::_internal_vertex_count() const {
  return _impl_.vertex_count_;
}
inline int32_t Statistics::vertex_count() const {
  // @@protoc_insertion_point(field_get:grin.Statistics.vertex_count)
  return _internal_vertex_count();
}
inline void Statistics::_internal_set_vertex_count(int32_t value) {
  
  _impl_.vertex_count_ = value;
}
inline void Statistics::set_vertex_count(int32_t value) {
  _internal_set_vertex_count(value);
  // @@protoc_insertion_point(field_set:grin.Statistics.vertex_count)
}

// int32 edge_count = 2;
inline void Statistics::clear_edge_count() {
  _impl_.edge_count_ = 0;
}
inline int32_t Statistics::_internal_edge_count() const {
  return _impl_.edge_count_;
}
inline int32_t Statistics::edge_count() const {
  // @@protoc_insertion_point(field_get:grin.Statistics.edge_count)
  return _internal_edge_count();
}
inline void Statistics::_internal_set_edge_count(int32_t value) {
  
  _impl_.edge_count_ = value;
}
inline void Statistics::set_edge_count(int32_t value) {
  _internal_set_edge_count(value);
  // @@protoc_insertion_point(field_set:grin.Statistics.edge_count)
}

// int32 partition_count = 3;
inline void Statistics::clear_partition_count() {
  _impl_.partition_count_ = 0;
}
inline int32_t Statistics::_internal_partition_count() const {
  return _impl_.partition_count_;
}
inline int32_t Statistics::partition_count() const {
  // @@protoc_insertion_point(field_get:grin.Statistics.partition_count)
  return _internal_partition_count();
}
inline void Statistics::_internal_set_partition_count(int32_t value) {
  
  _impl_.partition_count_ = value;
}
inline void Statistics::set_partition_count(int32_t value) {
  _internal_set_partition_count(value);
  // @@protoc_insertion_point(field_set:grin.Statistics.partition_count)
}

// int32 vertex_type_count = 4;
inline void Statistics::clear_vertex_type_count() {
  _impl_.vertex_type_count_ = 0;
}
inline int32_t Statistics::_internal_vertex_type_count() const {
  return _impl_.vertex_type_count_;
}
inline int32_t Statistics::vertex_type_count() const {
  // @@protoc_insertion_point(field_get:grin.Statistics.vertex_type_count)
  return _internal_vertex_type_count();
}
inline void Statistics::_internal_set_vertex_type_count(int32_t value) {
  
  _impl_.vertex_type_count_ = value;
}
inline void Statistics::set_vertex_type_count(int32_t value) {
  _internal_set_vertex_type_count(value);
  // @@protoc_insertion_point(field_set:grin.Statistics.vertex_type_count)
}

// int32 edge_type_count = 5;
inline void Statistics::clear_edge_type_count() {
  _impl_.edge_type_count_ = 0;
}
inline int32_t Statistics::_internal_edge_type_count() const {
  return _impl_.edge_type_count_;
}
inline int32_t Statistics::edge_type_count() const {
  // @@protoc_insertion_point(field_get:grin.Statistics.edge_type_count)
  return _internal_edge_type_count();
}
inline void Statistics::_internal_set_edge_type_count(int32_t value) {
  
  _impl_.edge_type_count_ = value;
}
inline void Statistics::set_edge_type_count(int32_t value) {
  _internal_set_edge_type_count(value);
  // @@protoc_insertion_point(field_set:grin.Statistics.edge_type_count)
}

// -------------------------------------------------------------------

// Graph

// string uri = 1;
inline void Graph::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& Graph::uri() const {
  // @@protoc_insertion_point(field_get:grin.Graph.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Graph::set_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grin.Graph.uri)
}
inline std::string* Graph::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:grin.Graph.uri)
  return _s;
}
inline const std::string& Graph::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void Graph::_internal_set_uri(const std::string& value) {
  
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* Graph::_internal_mutable_uri() {
  
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* Graph::release_uri() {
  // @@protoc_insertion_point(field_release:grin.Graph.uri)
  return _impl_.uri_.Release();
}
inline void Graph::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grin.Graph.uri)
}

// string grin_version = 2;
inline void Graph::clear_grin_version() {
  _impl_.grin_version_.ClearToEmpty();
}
inline const std::string& Graph::grin_version() const {
  // @@protoc_insertion_point(field_get:grin.Graph.grin_version)
  return _internal_grin_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Graph::set_grin_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.grin_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grin.Graph.grin_version)
}
inline std::string* Graph::mutable_grin_version() {
  std::string* _s = _internal_mutable_grin_version();
  // @@protoc_insertion_point(field_mutable:grin.Graph.grin_version)
  return _s;
}
inline const std::string& Graph::_internal_grin_version() const {
  return _impl_.grin_version_.Get();
}
inline void Graph::_internal_set_grin_version(const std::string& value) {
  
  _impl_.grin_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Graph::_internal_mutable_grin_version() {
  
  return _impl_.grin_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Graph::release_grin_version() {
  // @@protoc_insertion_point(field_release:grin.Graph.grin_version)
  return _impl_.grin_version_.Release();
}
inline void Graph::set_allocated_grin_version(std::string* grin_version) {
  if (grin_version != nullptr) {
    
  } else {
    
  }
  _impl_.grin_version_.SetAllocated(grin_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.grin_version_.IsDefault()) {
    _impl_.grin_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grin.Graph.grin_version)
}

// repeated .grin.StorageFeature features = 3;
inline int Graph::_internal_features_size() const {
  return _impl_.features_.size();
}
inline int Graph::features_size() const {
  return _internal_features_size();
}
inline void Graph::clear_features() {
  _impl_.features_.Clear();
}
inline ::grin::StorageFeature* Graph::mutable_features(int index) {
  // @@protoc_insertion_point(field_mutable:grin.Graph.features)
  return _impl_.features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grin::StorageFeature >*
Graph::mutable_features() {
  // @@protoc_insertion_point(field_mutable_list:grin.Graph.features)
  return &_impl_.features_;
}
inline const ::grin::StorageFeature& Graph::_internal_features(int index) const {
  return _impl_.features_.Get(index);
}
inline const ::grin::StorageFeature& Graph::features(int index) const {
  // @@protoc_insertion_point(field_get:grin.Graph.features)
  return _internal_features(index);
}
inline ::grin::StorageFeature* Graph::_internal_add_features() {
  return _impl_.features_.Add();
}
inline ::grin::StorageFeature* Graph::add_features() {
  ::grin::StorageFeature* _add = _internal_add_features();
  // @@protoc_insertion_point(field_add:grin.Graph.features)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grin::StorageFeature >&
Graph::features() const {
  // @@protoc_insertion_point(field_list:grin.Graph.features)
  return _impl_.features_;
}

// .grin.Statistics statistics = 4;
inline bool Graph::_internal_has_statistics() const {
  return this != internal_default_instance() && _impl_.statistics_ != nullptr;
}
inline bool Graph::has_statistics() const {
  return _internal_has_statistics();
}
inline void Graph::clear_statistics() {
  if (GetArenaForAllocation() == nullptr && _impl_.statistics_ != nullptr) {
    delete _impl_.statistics_;
  }
  _impl_.statistics_ = nullptr;
}
inline const ::grin::Statistics& Graph::_internal_statistics() const {
  const ::grin::Statistics* p = _impl_.statistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::grin::Statistics&>(
      ::grin::_Statistics_default_instance_);
}
inline const ::grin::Statistics& Graph::statistics() const {
  // @@protoc_insertion_point(field_get:grin.Graph.statistics)
  return _internal_statistics();
}
inline void Graph::unsafe_arena_set_allocated_statistics(
    ::grin::Statistics* statistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statistics_);
  }
  _impl_.statistics_ = statistics;
  if (statistics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grin.Graph.statistics)
}
inline ::grin::Statistics* Graph::release_statistics() {
  
  ::grin::Statistics* temp = _impl_.statistics_;
  _impl_.statistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grin::Statistics* Graph::unsafe_arena_release_statistics() {
  // @@protoc_insertion_point(field_release:grin.Graph.statistics)
  
  ::grin::Statistics* temp = _impl_.statistics_;
  _impl_.statistics_ = nullptr;
  return temp;
}
inline ::grin::Statistics* Graph::_internal_mutable_statistics() {
  
  if (_impl_.statistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::grin::Statistics>(GetArenaForAllocation());
    _impl_.statistics_ = p;
  }
  return _impl_.statistics_;
}
inline ::grin::Statistics* Graph::mutable_statistics() {
  ::grin::Statistics* _msg = _internal_mutable_statistics();
  // @@protoc_insertion_point(field_mutable:grin.Graph.statistics)
  return _msg;
}
inline void Graph::set_allocated_statistics(::grin::Statistics* statistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.statistics_;
  }
  if (statistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(statistics);
    if (message_arena != submessage_arena) {
      statistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statistics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.statistics_ = statistics;
  // @@protoc_insertion_point(field_set_allocated:grin.Graph.statistics)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace grin

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::grin::ListRetrieval> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grin::ListRetrieval>() {
  return ::grin::ListRetrieval_descriptor();
}
template <> struct is_proto_enum< ::grin::GraphPartitionStrategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grin::GraphPartitionStrategy>() {
  return ::grin::GraphPartitionStrategy_descriptor();
}
template <> struct is_proto_enum< ::grin::PropertyDataPartitionStrategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grin::PropertyDataPartitionStrategy>() {
  return ::grin::PropertyDataPartitionStrategy_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_graph_2eproto
